/*=============================================================================
** Module: address_generator.sv
** Description:
**              Address generator
** Author: Taeyoung Kong
** Change history: 04/10/2019 - Implement first version 
**                 05/09/2019 - INSTREAM, OUSTREAM modes are implemented
**===========================================================================*/

module `mname` #(
    parameter integer BANK_DATA_WIDTH = 64,
    parameter integer BANK_ADDR_WIDTH = 17,
    parameter integer CGRA_DATA_WIDTH = 16,
    parameter integer GLB_ADDR_WIDTH = 22
)
(
    input                           clk,
    input                           clk_en,
    input                           reset,

    input                           cgra_start_pulse,
    output logic                    cgra_done_pulse,

    input [GLB_ADDR_WIDTH-1:0]      start_addr,
    input [GLB_ADDR_WIDTH-1:0]      num_words,
    input [1:0]                     mode,

    input                           cgra_to_io_wr_en,
    input                           cgra_to_io_rd_en,
    input  [CGRA_DATA_WIDTH-1:0]    cgra_to_io_wr_data,
    output [CGRA_DATA_WIDTH-1:0]    io_to_cgra_rd_data,
    output                          io_to_cgra_rd_data_valid,
    input  [CGRA_DATA_WIDTH-1:0]    cgra_to_io_addr_high,
    input  [CGRA_DATA_WIDTH-1:0]    cgra_to_io_addr_low,
    
    output                          io_to_bank_wr_en,
    output [BANK_DATA_WIDTH-1:0]    io_to_bank_wr_data,
    output [BANK_DATA_WIDTH-1:0]    io_to_bank_wr_data_bit_sel,
    output                          io_to_bank_rd_en,
    input  [BANK_DATA_WIDTH-1:0]    bank_to_io_rd_data,
    output [GLB_ADDR_WIDTH-1:0]     io_to_bank_addr
);

//============================================================================//
// local parameter declaration
//============================================================================//
localparam integer UNUSED = 0;
localparam integer INSTREAM = 1;
localparam integer OUTSTREAM = 2;
localparam integer SRAM = 3;
localparam integer DATA_SEL_WIDTH = $clog2(BANK_DATA_WIDTH/CGRA_DATA_WIDTH); //2
localparam integer CGRA_DATA_BYTE = $ceil(CGRA_DATA_WIDTH/8); //2

//============================================================================//
// register to latch data from bank
//============================================================================//
logic                       io_to_bank_rd_en_d1; 
logic                       io_to_bank_rd_en_d2; 
logic [BANK_DATA_WIDTH-1:0] bank_to_io_rd_data_reg;
logic [BANK_DATA_WIDTH-1:0] int_bank_to_io_rd_data;

always_ff @(posedge clk) begin
    if (clk_en) begin
        io_to_bank_rd_en_d1 <= io_to_bank_rd_en;
        io_to_bank_rd_en_d2 <= io_to_bank_rd_en_d1;
        bank_to_io_rd_data_reg <= bank_to_io_rd_data;
    end
end
assign int_bank_to_io_rd_data = io_to_bank_rd_en_d2 ? bank_to_io_rd_data : bank_to_io_rd_data_reg;

//============================================================================//
// INSTREAM mode
//============================================================================//
typedef enum {IDLE, READY1, READY2, VALID} state_instream;
state_instream cur_state_instream, next_state_instream;

logic [GLB_ADDR_WIDTH-1:0]  int_addr_instream;
logic [GLB_ADDR_WIDTH-1:0]  next_addr_instream;

logic [GLB_ADDR_WIDTH-1:0]  num_words_cnt_instream;
logic [GLB_ADDR_WIDTH-1:0]  next_num_words_cnt_instream;

logic [DATA_SEL_WIDTH-1:0]  data_sel_instream;
logic [DATA_SEL_WIDTH-1:0]  data_sel_instream_d1;
logic [DATA_SEL_WIDTH-1:0]  data_sel_instream_d2;

logic                       int_rd_data_valid_instream;
logic                       int_rd_data_valid_instream_d1;

logic                       io_to_cgra_rd_data_valid_instream;
logic                       io_to_bank_rd_en_instream;

// Need mux to select CGRA_DATA from BANK_DATA due to DATA_WIDTH difference
// Need shift registers due to 2 cycle read latency
assign data_sel_instream = int_addr_instream[CGRA_DATA_BYTE-1 +: DATA_SEL_WIDTH];
always_ff @(posedge clk) begin
    if (clk_en) begin
        data_sel_instream_d1 <= data_sel_instream;
        data_sel_instream_d2 <= data_sel_instream_d1;
    end
end

// num_words_cnt decreases by 1 if it is non-zero
always_comb begin
    next_num_words_cnt_instream = num_words_cnt_instream;
    if (num_words_cnt_instream > 0) begin
        next_num_words_cnt_instream = num_words_cnt_instream - 1;
    end
end

// address increases by CGRA_DATA_BYTE if num_words_cnt is greater than 1
always_comb begin
    next_addr_instream = int_addr_instream;
    if (num_words_cnt_instream > 1) begin
        next_addr_instream = int_addr_instream + CGRA_DATA_BYTE;
    end
end

// When num_words_cnt is non-zero, rd_data_valid is positive
// Due to pipeline registers inside interconnect, we need shift register
assign int_rd_data_valid_instream = (num_words_cnt_instream > 0);
always_ff @(posedge clk) begin
    if (clk_en) begin
        int_rd_data_valid_instream_d1 <= int_rd_data_valid_instream;
    end
end

// FSM for instream mode
always_comb begin
    next_state_instream = cur_state_instream;
    if (mode == INSTREAM) begin
        case (cur_state_instream)
            IDLE: begin
                if (cgra_start_pulse) begin
                    next_state_instream = READY1;
                end
            end
            READY1: begin
                next_state_instream = READY2;
            end
            READY2, VALID: begin
                if (int_rd_data_valid_instream_d1)
                    next_state_instream = VALID;
                else
                    next_state_instream = IDLE;
            end
            default: begin
                next_state_instream = IDLE;
            end
        endcase
    end
end

// FSM register
always_ff @(posedge clk or posedge reset) begin
    if (reset) begin
        cur_state_instream <= IDLE;
        num_words_cnt_instream <= 0;
        int_addr_instream <= 0;
    end
    else if (clk_en) begin
        cur_state_instream <= next_state_instream;
        num_words_cnt_instream <= next_num_words_cnt_instream;
        int_addr_instream <= next_addr_instream;
    end
end

// output assignment
// io_to_cgra_rd_data_valid is high in VALID state
always_comb begin
    io_to_cgra_rd_data_valid_instream = 0;
    if (mode == INSTREAM) begin
        case (cur_state_instream)
            VALID: io_to_cgra_rd_data_valid_instream = 1;
            default: io_to_cgra_rd_data_valid_instream = 0;
        endcase
    end
end

// io_to_bank_rd_en is high when num_words_cnt is greater than 0
// and (READY1 state or data_sel is 2'b00)
always_comb begin
    io_to_bank_rd_en_instream = 0;
    if (mode == INSTREAM) begin
        if (num_words_cnt_instream) begin
            case (cur_state_instream)
                READY1: io_to_bank_rd_en_instream = 1;
                READY2, VALID: begin
                    if (data_sel_instream == {DATA_SEL_WIDTH{1'b0}}) 
                        io_to_bank_rd_en_instream = 1;
                    else
                        io_to_bank_rd_en_instream = 0;
                end
                default: 
                    io_to_bank_rd_en_instream = 0;
            endcase
        end
    end
end

//============================================================================//
// OUTSTREAM mode
//============================================================================//
typedef enum {IDLE, READY1, READY2, VALID} state_outstream;
state_oustream cur_state_outstream, next_state_oustream;

logic [GLB_ADDR_WIDTH-1:0]  int_addr_outstream;
logic [GLB_ADDR_WIDTH-1:0]  next_addr_outstream;

logic [GLB_ADDR_WIDTH-1:0]  num_words_cnt_outstream;
logic [GLB_ADDR_WIDTH-1:0]  next_num_words_cnt_outstream;

logic [DATA_SEL_WIDTH-1:0]  data_sel_outstream;
logic [DATA_SEL_WIDTH-1:0]  data_sel_outstream_d1;
logic [DATA_SEL_WIDTH-1:0]  data_sel_outstream_d2;

logic                       int_rd_data_valid_outstream;
logic                       int_rd_data_valid_outstream_d1;

logic                       io_to_cgra_rd_data_valid_outstream;
logic                       io_to_bank_rd_en_outstream;

// Need mux to select CGRA_DATA from BANK_DATA due to DATA_WIDTH difference
// Need shift registers due to 2 cycle read latency
assign data_sel_outstream = int_addr_outstream[CGRA_DATA_BYTE-1 +: DATA_SEL_WIDTH];
always_ff @(posedge clk) begin
    if (clk_en) begin
        data_sel_outstream_d1 <= data_sel_outstream;
        data_sel_outstream_d2 <= data_sel_outstream_d1;
    end
end

// num_words_cnt decreases by 1 if it is non-zero
always_comb begin
    next_num_words_cnt_outstream = num_words_cnt_outstream;
    if (num_words_cnt_outstream > 0) begin
        next_num_words_cnt_outstream = num_words_cnt_outstream - 1;
    end
end

// address increases by CGRA_DATA_BYTE if num_words_cnt is greater than 1
always_comb begin
    next_addr_outstream = int_addr_outstream;
    if (num_words_cnt_outstream > 1) begin
        next_addr_outstream = int_addr_outstream + CGRA_DATA_BYTE;
    end
end

// When num_words_cnt is non-zero, rd_data_valid is positive
// Due to pipeline registers inside interconnect, we need shift register
assign int_rd_data_valid_outstream = (num_words_cnt_outstream > 0);
always_ff @(posedge clk) begin
    if (clk_en) begin
        int_rd_data_valid_outstream_d1 <= int_rd_data_valid_outstream;
    end
end

// FSM for outstream mode
always_comb begin
    next_state_outstream = cur_state_outstream;
    if (mode == INSTREAM) begin
        case (cur_state_outstream)
            IDLE: begin
                if (cgra_start_pulse) begin
                    next_state_outstream = READY1;
                end
            end
            READY1: begin
                next_state_outstream = READY2;
            end
            READY2, VALID: begin
                if (int_rd_data_valid_outstream_d1)
                    next_state_outstream = VALID;
                else
                    next_state_outstream = IDLE;
            end
            default: begin
                next_state_outstream = IDLE;
            end
        endcase
    end
end

// FSM register
always_ff @(posedge clk or posedge reset) begin
    if (reset) begin
        cur_state_outstream <= IDLE;
        num_words_cnt_outstream <= 0;
        int_addr_outstream <= 0;
    end
    else if (clk_en) begin
        cur_state_outstream <= next_state_outstream;
        num_words_cnt_outstream <= next_num_words_cnt_outstream;
        int_addr_outstream <= next_addr_outstream;
    end
end

// output assignment
// io_to_cgra_rd_data_valid is high in VALID state
always_comb begin
    io_to_cgra_rd_data_valid_outstream = 0;
    if (mode == INSTREAM) begin
        case (cur_state_outstream)
            VALID: io_to_cgra_rd_data_valid_outstream = 1;
            default: io_to_cgra_rd_data_valid_outstream = 0;
        endcase
    end
end

// io_to_bank_rd_en is high when num_words_cnt is greater than 0
// and (READY1 state or data_sel is 2'b00)
always_comb begin
    io_to_bank_rd_en_outstream = 0;
    if (mode == INSTREAM) begin
        if (num_words_cnt_outstream) begin
            case (cur_state_outstream)
                READY1: io_to_bank_rd_en_outstream = 1;
                READY2, VALID: begin
                    if (data_sel_outstream == {DATA_SEL_WIDTH{1'b0}}) 
                        io_to_bank_rd_en_outstream = 1;
                    else
                        io_to_bank_rd_en_outstream = 0;
                end
                default: 
                    io_to_bank_rd_en_outstream = 0;
            endcase
        end
    end
end

endmodule
