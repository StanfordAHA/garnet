/*=============================================================================
** Module: address_generator.sv
** Description:
**              Address generator
** Author: Taeyoung Kong
** Change history: 04/10/2019 - Implement first version 
**                 05/09/2019 - INSTREAM, OUSTREAM modes are implemented
**===========================================================================*/

module `mname` #(
    parameter integer BANK_DATA_WIDTH = 64,
    parameter integer BANK_ADDR_WIDTH = 17,
    parameter integer CGRA_DATA_WIDTH = 16,
    parameter integer GLB_ADDR_WIDTH = 22
)
(
    input                           clk,
    input                           clk_en,
    input                           reset,

    input                           cgra_start_pulse,
    output logic                    cgra_done_pulse,

    input [GLB_ADDR_WIDTH-1:0]      start_addr,
    input [GLB_ADDR_WIDTH-1:0]      num_words,
    input [1:0]                     mode,

    input                           cgra_to_io_wr_en,
    input                           cgra_to_io_rd_en,
    input  [CGRA_DATA_WIDTH-1:0]    cgra_to_io_wr_data,
    output [CGRA_DATA_WIDTH-1:0]    io_to_cgra_rd_data,
    output                          io_to_cgra_rd_data_valid,
    input  [CGRA_DATA_WIDTH-1:0]    cgra_to_io_addr_high,
    input  [CGRA_DATA_WIDTH-1:0]    cgra_to_io_addr_low,
    
    output                          io_to_bank_wr_en,
    output [BANK_DATA_WIDTH-1:0]    io_to_bank_wr_data,
    output [BANK_DATA_WIDTH-1:0]    io_to_bank_wr_data_bit_sel,
    output                          io_to_bank_rd_en,
    input  [BANK_DATA_WIDTH-1:0]    bank_to_io_rd_data,
    output [GLB_ADDR_WIDTH-1:0]     io_to_bank_addr
);

//============================================================================//
// local parameter declaration
//============================================================================//
localparam integer UNUSED = 0;
localparam integer INSTREAM = 1;
localparam integer OUTSTREAM = 2;
localparam integer SRAM = 3;
localparam integer DATA_SEL_WIDTH = $clog2(BANK_DATA_WIDTH/CGRA_DATA_WIDTH); //2
localparam integer CGRA_DATA_BYTE = $ceil(CGRA_DATA_WIDTH/8); //2

//============================================================================//
// register to latch data from bank
//============================================================================//
logic                       io_to_bank_rd_en_d1; 
logic                       io_to_bank_rd_en_d2; 
logic [BANK_DATA_WIDTH-1:0] bank_to_io_rd_data_reg;
logic [BANK_DATA_WIDTH-1:0] int_bank_to_io_rd_data;

always_ff @(posedge clk) begin
    if (clk_en) begin
        io_to_bank_rd_en_d1 <= io_to_bank_rd_en;
        io_to_bank_rd_en_d2 <= io_to_bank_rd_en_d1;
        bank_to_io_rd_data_reg <= bank_to_io_rd_data;
    end
end
assign int_bank_to_io_rd_data = io_to_bank_rd_en_d2 ? bank_to_io_rd_data : bank_to_io_rd_data_reg;

//============================================================================//
// INSTREAM mode
//============================================================================//
enum {IDLE, READ} state_instream;

logic [GLB_ADDR_WIDTH-1:0]  int_addr_instream;

logic [GLB_ADDR_WIDTH-1:0]  num_words_cnt_instream;

logic [DATA_SEL_WIDTH-1:0]  data_sel_instream;
logic [DATA_SEL_WIDTH-1:0]  data_sel_instream_d1;
logic [DATA_SEL_WIDTH-1:0]  data_sel_instream_d2;

logic                       int_rd_data_valid_instream;
logic                       int_rd_data_valid_instream_d1;
logic                       int_rd_data_valid_instream_d2;

logic                       io_to_cgra_rd_data_valid_instream;
logic [CGRA_DATA_WIDTH-1:0] io_to_cgra_rd_data_instream;
logic                       io_to_bank_rd_en_instream;

// Need mux to select CGRA_DATA from BANK_DATA due to DATA_WIDTH difference
assign data_sel_instream = int_addr_instream[CGRA_DATA_BYTE-1 +: DATA_SEL_WIDTH];

// FSM for INSTREAM mode
// address increases by CGRA_DATA_BYTE if num_words_cnt is greater than 1
// num_words_cnt decreases by 1 if it is non-zero
always_ff @(posedge clk or posedge reset) begin
    if (reset) begin
        state_instream <= IDLE;
        num_words_cnt_instream <= 0;
        int_addr_instream <= 0;
        io_to_bank_rd_en_instream <= 0;
    end
    else if (clk_en) begin
        if (mode == INSTREAM) begin
            case (state_instream)
                IDLE: begin
                    if (cgra_start_pulse && (num_words > 0)) begin
                        state_instream <= READ;
                        num_words_cnt_instream <= num_words;
                        int_addr_instream <= start_addr;
                        io_to_bank_rd_en_instream <= 1;
                    end
                end
                READ: begin
                    if (num_words_cnt_instream == 1) begin
                        state_instream <= IDLE;
                        num_words_cnt_instream <= 0;
                        int_addr_instream <= int_addr_instream;
                        io_to_bank_rd_en_instream <= 0;
                    end
                    else begin
                        state_instream <= READ;
                        num_words_cnt_instream <= num_words_cnt_instream - 1;
                        int_addr_instream <= int_addr_instream + CGRA_DATA_BYTE;
                        // bank_rd_en goes high only when the last word is read
                        io_to_bank_rd_en_instream <= (data_sel_instream == {DATA_SEL_WIDTH{1'b1}});
                    end
                end
                default: begin
                    state_instream <= IDLE;
                    num_words_cnt_instream <= 0;
                    int_addr_instream <= int_addr_instream;
                    io_to_bank_rd_en_instream <= 0;
                end
            endcase
        end
    end
end

// When num_words_cnt is non-zero, rd_data_valid is positive
// io_to_cgra_rd_data_valid goes high 2 cycles after num_cnt is greater than 0
// due to read latency
assign int_rd_data_valid_instream = (num_words_cnt_instream > 0);
always_ff @(posedge clk) begin
    if (clk_en) begin
        int_rd_data_valid_instream_d1 <= int_rd_data_valid_instream;
        int_rd_data_valid_instream_d2 <= int_rd_data_valid_instream_d1;
    end
end
assign io_to_cgra_rd_data_valid_instream = int_rd_data_valid_instream_d2;

// Need mux to select CGRA_DATA from BANK_DATA due to DATA_WIDTH difference
always_ff @(posedge clk) begin
    if (clk_en) begin
        data_sel_instream_d1 <= data_sel_instream;
        data_sel_instream_d2 <= data_sel_instream_d1;
    end
end
assign io_to_cgra_rd_data_instream = int_bank_to_io_rd_data[data_sel_instream_d2 * CGRA_DATA_WIDTH +: CGRA_DATA_WIDTH];


endmodule
