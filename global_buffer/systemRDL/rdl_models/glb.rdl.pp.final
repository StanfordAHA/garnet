addrmap glb {
    name = "glb";
    desc = "Global Buffer Register Space";
    default alignment = 4;
    default addressing = compact;
    default littleendian;
    default lsb0;
    default sharedextbus;
    default sw = rw;
    default hw = r;
    default regwidth = 32;
    default accesswidth = 32;
    reg tile_ctrl_r {
        name = "Tile Control Registers";
        desc = "Number of cycles to hold soft reset signal";
        field {
            desc = "Set: This tile is connected to next (right) tile for streaming data";
        } tile_connected = 0;
        field {
            desc = "Set: This tile is connected to next (right) tile for streaming bitstream";
        } pc_tile_connected = 0;
        field {
            desc = "bit[0]: stream to col0, bit[1]: stream to col1";
        } strm_g2f_mux[2] = 0;
        field {
            desc = "bit[0]: stream from col0, bit[1]: stream from col1. Only one bit should be set";
        } strm_f2g_mux[2] = 0;
        field {
            desc = "2'b00: OFF, 2'b01: NORMAL, 2'b10: REPEAT, 2'b11: AUTO_INCR";
        } ld_dma_mode[2] = 0;
        field {
            desc = "2'b00: OFF, 2'b01: NORMAL, 2'b10: REPEAT, 2'b11: AUTO_INCR";
        } st_dma_mode[2] = 0;
        field {
            desc = "0: OFF, 1: ON";
        } pc_dma_mode = 0;
    };
    reg latency_r {
        name = "Transaction Latency Registers";
        desc = "Need to be set to the total number of tiles connected";
        field {} latency[4] = 0;
    };
    reg validate_r {
        name = "Validate";
        desc = "Validate this header";
        field {hwclr;} validate = 0;
    };
    reg start_addr_r {
        name = "Start Address";
        desc = "Start address of DMA header";
        field {} start_addr[22] = 0;
    };
    reg num_words_r {
        name = "Num Words";
        desc = "Number of words of DMA header";
        field {} num_words[21] = 0;
    };
    reg iter_ctrl_r {
        name = "Iteration Control";
        desc = "Iteration control registers";
        field {} range[21] = 0;
        field {} stride[11] = 0;
    };
    reg active_ctrl_r {
        name = "Stream Active/Inactive Control";
        desc = "Number of active/inactive stream";
        field {} num_active_words[16] = 0;
        field {} num_inactive_words[16] = 0;
    };
    regfile st_dma_header_rf {
        name = "Store DMA Header Register File";
        desc = "Registers needed for one store DMA header";
        validate_r validate;
        start_addr_r start_addr;
        num_words_r num_words;
    };
    regfile ld_dma_header_rf {
        name = "Load DMA Header Register File";
        desc = "Registers needed for one load DMA header";
        validate_r validate;
        start_addr_r start_addr;
        active_ctrl_r active_ctrl; 
        iter_ctrl_r iter_ctrl_0;
        iter_ctrl_r iter_ctrl_1;
        iter_ctrl_r iter_ctrl_2;
        iter_ctrl_r iter_ctrl_3;
    };
    reg num_cfg_r {
        name = "Num Cfgs";
        desc = "Number of configuration bitstream";
        field {} num_cfgs[19] = 0;
    };
    regfile pc_dma_header_rf {
        name = "Parallel Configuration DMA Header Register File";
        desc = "Registers needed for Parallel Configuration";
        start_addr_r start_addr;
        num_cfg_r num_cfg;
    };
    tile_ctrl_r tile_ctrl;
    latency_r latency;
    latency_r pc_latency;
    st_dma_header_rf st_dma_header_0;
    st_dma_header_rf st_dma_header_1;
    st_dma_header_rf st_dma_header_2;
    st_dma_header_rf st_dma_header_3;
    ld_dma_header_rf ld_dma_header_0;
    ld_dma_header_rf ld_dma_header_1;
    ld_dma_header_rf ld_dma_header_2;
    ld_dma_header_rf ld_dma_header_3;
    pc_dma_header_rf pc_dma_header;
};
