// ========================================================================
// Perl Embedding
// ========================================================================
<% 
use constant NUM_GLB_TILES => 16;
use constant GLB_ADDR_WIDTH => 22;
%>

// ========================================================================
// Address map
// ========================================================================
addrmap glc {
    name = "glc";
    desc = "Global Controller Register Space";

    default addressing = regalign;
    default alignment = 4;
    default littleendian;
    default lsb0;

    default sw = rw;
    default hw = r;

    default regwidth = 32;
    default accesswidth = 32;

    // ========================================================================
    // Global Controller Registers
    // ========================================================================

    reg test_r {
        name = "Test Register";
        desc = "Test register to check if AXI-LITE is working";            
        field { hw = na; } value[31:0] = 0x0;
    };

    reg global_reset_r {
        name = "Global Reset Counter";
        desc = "Number of cycles to hold global reset signal";
        field { hw = rw; we; } cnt[31:0] = 0x0;
    };

    reg soft_reset_r {
        name = "Soft Reset Counter";
        desc = "Number of cycles to hold soft reset signal";
        field { hw = rw; we; } cnt[31:0] = 0x0;
    };

    reg stall_r {
        name = "Stall";
        desc = "Bit1: global buffer stall, Bit0: cgra stall";
        field {} stall[1:0] = 0x0;
    };

    reg stream_start_pulse_r {
        name = "Stream Start";
        desc = "Start data streaming from glb tile";
        <% for ($i = 0; $i < NUM_GLB_TILES; $i += 1) { %>
        field {singlepulse; hw = na;} glb_tile_<%=$i%> = 0x0;
        <% } %>
    };

    reg pc_start_pulse_r {
        name = "Parallel Config Start";
        desc = "Start bitstream streaming from glb tile";
        <% for ($i = 0; $i < NUM_GLB_TILES; $i += 1) { %>
        field {singlepulse; hw = na;} glb_tile_<%=$i%> = 0x0;
        <% } %>
    };

    // ========================================================================
    // Block Level Interrupt Status Register
    // ========================================================================
    reg strm_g2c_isr_r {
        name = "Stream From GLB to CGRA Interrupt Status Register";
        desc = "Data stream from glb to cgra interrupt status register for each glb tile";

		default hw = w;
        default sw = rw; // Software can clear
        default woclr; // Clear is via writing a 1

        <% for ($i = 0; $i < NUM_GLB_TILES; $i += 1) { %>
        field { 
			desc = "glb_tile_<%=$i%> data stream from glb to cgra interrupt";
			level intr;
		} tile_<%=$i%>[<%=$i%>:<%=$i%>] = 0x0;
        <% } %>
    };

    reg strm_c2g_isr_r {
        name = "Stream From CGRA to GLB Interrupt Status Register";
        desc = "Data stream from cgra to glb interrupt status register for each glb tile";

		default hw = w;
        default sw = rw; // Software can clear
        default woclr; // Clear is via writing a 1

        <% for ($i = 0; $i < NUM_GLB_TILES; $i += 1) { %>
        field { 
			desc = "glb_tile_<%=$i%> data stream from cgra to glb interrupt";
			level intr;
		} tile_<%=$i%>[<%=$i%>:<%=$i%>] = 0x0;
        <% } %>
    };

    reg par_cfg_g2c_isr_r {
        name = "Parallel Configuration From CGRA to GLB Interrupt Status Register";
        desc = "Parallel configuration stream from cgra to glb interrupt status register for each glb tile";

		default hw = w;
        default sw = rw; // Software can clear
        default woclr; // Clear is via writing a 1

        <% for ($i = 0; $i < NUM_GLB_TILES; $i += 1) { %>
        field { 
			desc = "glb_tile_<%=$i%> data stream from cgra to glb interrupt";
			level intr;
		} tile_<%=$i%>[<%=$i%>:<%=$i%>] = 0x0;
        <% } %>
    };

    // ========================================================================
    // Block Level Interrupt Enable Register
    // ========================================================================
    reg strm_g2c_ier_r {
        name = "Stream From GLB to CGRA Interrupt Enable Register";
        desc = "Data stream from glb to cgra interrupt enable register for each glb tile";

		default hw = na;
        default sw = rw; // Software can clear

        <% for ($i = 0; $i < NUM_GLB_TILES; $i += 1) { %>
        field { 
			desc = "glb_tile_<%=$i%> data stream from glb to cgra interrupt enable reg";
		} tile_<%=$i%>[<%=$i%>:<%=$i%>] = 0x0;
        <% } %>
    };

    reg strm_c2g_ier_r {
        name = "Stream From CGRA to GLB Interrupt Enable Register";
        desc = "Data stream from cgra to glb interrupt enable register for each glb tile";

		default hw = na;
        default sw = rw; // Software can clear

        <% for ($i = 0; $i < NUM_GLB_TILES; $i += 1) { %>
        field { 
			desc = "glb_tile_<%=$i%> data stream from cgra to glb interrupt enable reg";
			level intr;
		} tile_<%=$i%>[<%=$i%>:<%=$i%>] = 0x0;
        <% } %>
    };

    reg par_cfg_g2c_ier_r {
        name = "Parallel Configuration From CGRA to GLB Interrupt Enable Register";
        desc = "Parallel configuration stream from cgra to glb interrupt enable register for each glb tile";

		default hw = na;
        default sw = rw; // Software can clear

        <% for ($i = 0; $i < NUM_GLB_TILES; $i += 1) { %>
        field { 
			desc = "glb_tile_<%=$i%> data stream from cgra to glb interrupt enable reg";
			level intr;
		} tile_<%=$i%>[<%=$i%>:<%=$i%>] = 0x0;
        <% } %>
    };

    // ========================================================================
    // Global Interrupt Status Register
    // ========================================================================
    reg global_isr_r {
        name = "Global Interrupt Status Register";
        desc = "This register contains the status of the three lower block interrupts.
                Also an interrupt signal (interrupt) is generated which is the 'OR'
                of the three block interrupts. Three blocks are 'data_strm_glb_to_cgra',
                'data_strm_cgra_to_glb', and 'parallel_config_glb_to_cgra'";

        default nonsticky intr;
		default hw = w;
        default sw = r; // Software can just read this. It clears the block interrupt to

        field { 
			desc = "Interrupt status register of data streaming from glb to cgra";
			level intr;
		} strm_g2c[0:0] = 0x0;

        field { 
			desc = "Interrupt status register of data streaming from cgra to glb";
			level intr;
		} strm_c2g[1:1] = 0x0;

        field { 
			desc = "Interrupt status register of bitstream streaming from glb to cgra";
			level intr;
		} par_cfg_g2c[2:2] = 0x0;

    };

    // ========================================================================
    // Global Interrupt Enable Register
    // ========================================================================
    reg global_ier_r {
        name = "Global Interrupt Enable Register";
        desc = "Configurable register used in order to enable the corresponding interrupts
                found in Global Interrupt Status Register";
		default hw = na;
        default sw = rw;

        field { 
			desc = "Interrupt enable register of data streaming from glb to cgra";
		} strm_g2c[0:0] = 0x0;

        field { 
			desc = "Interrupt enable register of data streaming from cgra to glb";
		} strm_c2g[1:1] = 0x0;

        field { 
			desc = "Interrupt enable register of bitstream streaming from glb to cgra";
		} par_cfg_g2c[2:2] = 0x0;
    };
    
    // ========================================================================
    // Register Instantiation and Connection
    // ========================================================================
    test_r                  test;
    global_reset_r          global_reset;
    soft_reset_r            soft_reset;
    stall_r                 stall;
    stream_start_pulse_r    stream_start_pulse;
    pc_start_pulse_r        pc_start_pulse;

    strm_g2c_ier_r          strm_g2c_ier;
    strm_c2g_ier_r          strm_c2g_ier;
    par_cfg_g2c_ier_r       par_cfg_g2c_ier;
    global_ier_r            global_ier;

    strm_g2c_isr_r          strm_g2c_isr;
    strm_c2g_isr_r          strm_c2g_isr;
    par_cfg_g2c_isr_r       par_cfg_g2c_isr;
    global_isr_r            global_isr;

    <% for ($i = 0; $i < NUM_GLB_TILES; $i += 1) { %>
    strm_g2c_isr.tile_<%=$i%>->enable = strm_g2c_ier.tile_<%=$i%>;
    strm_c2g_isr.tile_<%=$i%>->enable = strm_c2g_ier.tile_<%=$i%>;
    par_cfg_g2c_isr.tile_<%=$i%>->enable = par_cfg_g2c_ier.tile_<%=$i%>;
    <% } %>
    global_isr.strm_g2c->enable = global_ier.strm_g2c;
    global_isr.strm_c2g->enable = global_ier.strm_c2g;
    global_isr.par_cfg_g2c->enable = global_ier.par_cfg_g2c;

    // Connect block level interrupt to global level interrupt
    global_isr.strm_g2c->next = strm_g2c_isr->intr;
    global_isr.strm_c2g->next = strm_c2g_isr->intr;
    global_isr.par_cfg_g2c->next = par_cfg_g2c_isr->intr;




















    // reg {
    //     name = "CGRA Config Read Delay";
    //     desc = "Number of cycles RD_ENABLE signal is asserted when reading cgra config";
    //     field {} VALUE[31:0] = 0x0;
    // } cgra_cfg_rd_delay @ 0x0C;
    //     
    // reg {
    //     name = "Config Address";
    //     desc = "Address that CGRA_CONFIG_DATA should be written to";
    //     field {} VALUE[31:0] = 0x0;
    // } CGRA_CONFIG_ADDR @ 0x2C;

    // reg {
    //     name = "Config Data";
    //     desc = "Config data";
    //     field {} VALUE[31:0] = 0x0;
    // } CGRA_CONFIG_DATA @ 0x30;

    // reg {
    //     name = "GLB SRAM Address";
    //     desc = "Address of GLB SRAM to write to";
    //     field {} VALUE[31:0] = 0x0;
    // } GLB_SRAM_CONFIG_ADDR @ 0x34;

    // reg {
    //     name = "GLB SRAM Data";
    //     desc = "Data to write to GLB SRAM";
    //     field {} VALUE[31:0] = 0x0;
    // } GLB_SRAM_CONFIG_DATA @ 0x38;

    // reg {
    //     name = "GLB SRAM Write Enable";
    //     desc = "Enable GLB SRAM Writes";
    //     field {singlepulse;} VALUE[0:0] = 0x0;
    // } GLB_SRAM_WRITE_EN @ 0x3C;
};

