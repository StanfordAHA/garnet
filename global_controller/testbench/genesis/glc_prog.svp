/* *****************************************************************************
 * File: test.v
 * Author: Ofer Shacham
 * 
 * Description:
 * simple test bench for template
 * 
 *
 * Change bar:
 * -----------
 * Date                  Author     Description
 * Apr 3, 2010  shacham  initial version
 *  
 * 
 * ****************************************************************************/

////////////////////////////// IMPORTANT MESSAGE: //////////////////////////////
// Note that programs are written using object oriented programming. They
// are closer to software than to hardware. There is therefore no real need
// in a genesis type parameterization.
////////////////////////////////////////////////////////////////////////////////

// parameter definition
//; my $config_addr_width = parameter(name => 'config_addr_width', val=>32);
//; my $config_data_width = parameter(name => 'config_data_width', val=>32);
//; my $axi_addr_width = parameter(Name=>'axi_addr_width',val=>13);
//; my $axi_data_width = parameter(NAME => 'axi_data_width', VAL => 32, DOC => 'Width of axi_data');
//; my $block_axi_addr_width = parameter(NAME => 'block_axi_addr_width', VAL => 12, DOC => 'Width of axi_addr for sub block');
//; my $num_glb_tiles = parameter(NAME => 'num_glb_tiles', VAL => 16, DOC => 'number of global buffer tiles');
//; my $glb_addr_width = parameter(NAME => 'glb_addr_width', VAL => 22, DOC => 'Width of glb_addr');

program automatic `mname`(interface dut_ifc, interface jtag_ifc, interface axi_ifc);
    
    // some variables to control the test
    int seed;
    int rnd0;
    int file_desc;
    int config_count=0;
    enum {other, cgra_reading, cgra_writing, glb_reading, glb_writing, sram_reading, sram_writing} state = other; 
    enum {axi4, jtag} gc_interface = jtag; 

    // Instantiate a jtag driver
    //; my $jtag_drvr_obj = generate_base('jtag_driver', 'jtag_driver');
    //; my $axi_drvr_obj = generate_base('axi_driver', 'axi_driver');
    `$jtag_drvr_obj->instantiate`;
    `$axi_drvr_obj->instantiate`;

    jtag_regfile_trans_t jtag_trans;
    axi_trans_t axi_trans;

    //============================================================================//
    //Property assertion
    //============================================================================//
    assert property (!(top.dut.cgra_cfg_read && top.dut.cgra_cfg_write)) else $error("read and write both asserted");
    assert property (!((state==cgra_reading) && (top.dut.cgra_cfg_write))) else $error("write asserted while reading");
    assert property (!((state==glb_reading) && (top.dut.glb_cfg_wr_en))) else $error("glb write asserted while glb reading");
    assert property (!((state==sram_reading) && (top.dut.sram_cfg_wr_en))) else $error("glb sram write asserted while glb sram reading");
    assert property (!((state==cgra_writing) && (top.dut.cgra_cfg_read))) else $error("read asserted while writing");
    assert property (!((state==glb_writing) && (top.dut.glb_cfg_rd_en))) else $error("glb read asserted while glb writing");
    assert property (!((state==sram_writing) && (top.dut.sram_cfg_rd_en))) else $error("glb sram read asserted while glb sram writing");
    assert property (!((state==other) && (top.dut.cgra_cfg_read | top.dut.cgra_cfg_write))) else $error("cgra cfg r/w asserted while not doing either");
    assert property (!((state==other) && (top.dut.glb_cfg_wr_en | top.dut.glb_cfg_rd_en))) else $error("glb cfg r/w asserted while not doing either");
    assert property (!((state==other) && (top.dut.sram_cfg_wr_en | top.dut.sram_cfg_rd_en))) else $error("sram cfg r/w asserted while not doing either");

    //============================================================================//
    //Add assertions for read sequence
    //At some point during the read, the output address must equal the input address
    //and the read signal must be asserted
    //============================================================================//
    // JTAG read
    sequence begin_jtag_cgra_read;
           ((gc_interface==jtag) && ~(state==cgra_reading)) ##1 (state==cgra_reading);
    endsequence
    
    sequence assert_jtag_cgra_read;
           ##[0:400] (state==cgra_reading) && (top.dut.cgra_cfg_read==1)
           && (top.dut.cgra_cfg_addr==jtag_trans.addr);
    endsequence
    
    property correct_jtag_cgra_read;
           @(posedge dut_ifc.Clk)
           begin_jtag_cgra_read |-> assert_jtag_cgra_read;
    endproperty
       
    assert property(correct_jtag_cgra_read) else $error("incorrect jtag_read sequence");
    
    //============================================================================//
    //Add assertions for write sequence
    //At some point during the write, the output address must equal the input address,
    //output data must equal input data, and the write signal must be asserted
    //============================================================================//
    // JTAG write
    sequence begin_jtag_cgra_write;
           ((gc_interface==jtag) && ~(state==cgra_writing)) ##1 (state==cgra_writing);
    endsequence
    
    sequence assert_jtag_cgra_write;
           ##[0:800] (state==cgra_writing) && (top.dut.cgra_cfg_write==1)
           && (top.dut.cgra_cfg_addr==jtag_trans.addr) && (top.dut.cgra_cfg_wr_data==jtag_trans.data_in);
    endsequence
    
    property correct_jtag_cgra_write;
           @(posedge dut_ifc.Clk)
           begin_jtag_cgra_write |-> assert_jtag_cgra_write;
    endproperty
       
    assert property(correct_jtag_cgra_write) else $error("incorrect write sequence");
    
    

    //============================================================================//
    // run_test task
    //============================================================================//
    task run_test; begin
    logic [`$config_addr_width-1`:0] addr;
    logic [`$config_data_width-1`:0] data;

    // read ID
    jtag_driver.ReadID(jtag_trans);
    
    // initialization of structs:
    jtag_trans.domain = sc_domain;
    jtag_trans.addr = `$config_addr_width`'d0;
    jtag_trans.op = nop;
    jtag_trans.data_out = '0;
    
    @(posedge dut_ifc.Clk);
    switch_clk(0); // Switch to slow clk

    @(posedge dut_ifc.Clk);
    switch_clk(1); // Switch to fast clk

    // Write TST
    @(posedge dut_ifc.Clk);
    write_gc_reg(wr_TST, 32'd10);
    repeat(2) jtag_driver.Next_tck();

    // Read TST
    @(posedge dut_ifc.Clk);
    read_gc_reg(rd_TST);

    // writeread delay register
    @(posedge dut_ifc.Clk);
    write_gc_reg(wr_rd_delay_reg, 32'd10);
    repeat(2) jtag_driver.Next_tck();

    // write cgra config
    @(posedge dut_ifc.Clk);
    write_config();

    // read cgra config
    @(posedge dut_ifc.Clk);
    read_config(); 
    repeat(50) jtag_driver.Next_tck();
       
    // // cgra stall
    // @(posedge dut_ifc.Clk);
    // write_gc_reg(write_stall,32'b01);
    // repeat(2) jtag_driver.Next_tck();
    //  
    // // glb stall
    // @(posedge dut_ifc.Clk);
    // write_gc_reg(write_stall,32'b10);
    // repeat(2) jtag_driver.Next_tck();

    // // both stall
    // @(posedge dut_ifc.Clk);
    // write_gc_reg(write_stall,32'b11);
    // repeat(2) jtag_driver.Next_tck();

    // @(posedge dut_ifc.Clk);
    // jtag_trans.op = advance_clk;
    // jtag_trans.data_in = 32'd6;
    // jtag_trans.addr = 32'b1010;
    // jtag_trans.done = 0;
    // jtag_driver.Send(jtag_trans);

    // // unstall
    // @(posedge dut_ifc.Clk);
    // write_gc_reg(write_stall,32'b00);
    // repeat(2) jtag_driver.Next_tck();
 
    // // global reset
    // @(posedge dut_ifc.Clk);
    // jtag_trans.op = global_reset;
    // jtag_trans.data_in = 32'd50;
    // jtag_trans.done = 0;
    // jtag_driver.Send(jtag_trans);

    // // soft reset
    // @(posedge dut_ifc.Clk);
    // jtag_trans.op = soft_reset;
    // jtag_trans.data_in = 32'd50;
    // jtag_trans.done = 0;
    // jtag_driver.Send(jtag_trans);

    // @(posedge dut_ifc.Clk);
    // write_glb_config(32'd1234, 32'd5678);

    // @(posedge dut_ifc.Clk);
    // read_glb_config(32'd1234);

    // @(posedge dut_ifc.Clk);
    // write_glb_sram_config(32'd9876, 32'd5432);

    // @(posedge dut_ifc.Clk);
    // read_glb_sram_config(32'd9876);

    repeat(50) jtag_driver.Next_tck();
    end
    endtask // run_test


    /****************************************************************************
       * Control the simulation
       * *************************************************************************/
    initial begin
        $display("%t:\t********************Loading Arguments***********************",$time);
        init_test;
        file_desc = $fopen("test.log","w");
        
        $display("%t:\t*************************START*****************************",$time);
        @(negedge dut_ifc.Reset);
        repeat (10) @(posedge dut_ifc.Clk);
        run_test;
        repeat (10) @(posedge dut_ifc.Clk);
        $display("%t:\t*************************FINISH****************************",$time);
        $fclose(file_desc);
        $finish(2);
    end
    
    task write_config();
    begin
        state = cgra_writing;
        gc_interface = jtag;
        jtag_trans.op = write;
        jtag_trans.addr = $urandom_range((2 ** `$config_addr_width`)-1);
        jtag_trans.data_in = $urandom_range((2 ** `$config_data_width`)-1);
        jtag_trans.done = 0;
        config_count++;
        jtag_driver.Send(jtag_trans);
        $fdisplay(file_desc,"%t: %m: Trans %d (Write):    Address to GC=%d, Data to GC=%d",  
            $time, config_count,dut_ifc.cgra_cfg_addr, dut_ifc.cgra_cfg_wr_data);
        @(posedge dut_ifc.Clk);
        state = other;
    end
    endtask //write_config
       
    task read_config();
    begin
        state = cgra_reading;
        gc_interface = jtag;
        jtag_trans.op = read;
        jtag_trans.addr = $urandom_range((2 ** `$config_addr_width`)-1);
        jtag_trans.data_in = '0;
        jtag_trans.done = 0;
        dut_ifc.cgra_cfg_rd_data = $urandom_range((2 ** `$config_data_width`)-1);
        jtag_driver.Send(jtag_trans);
        config_count++;
        jtag_trans = jtag_driver.GetResult();
        $fdisplay(file_desc,"%t: %m: Trans %d (Read):  Address to GC=%d, Data to GC=%d, Data from CGRA=%d, Data Read=%d",  
            $time, config_count, dut_ifc.cgra_cfg_addr, dut_ifc.cgra_cfg_wr_data, top.dut.cgra_cfg_rd_data, jtag_trans.data_out);
        state = other;
    end
    endtask //read_config
    
    task switch_clk(int data_in);
    begin
        gc_interface = jtag;
        jtag_trans.op = switch_clk;
        jtag_trans.data_in = data_in;
        jtag_trans.done = 0;
        jtag_driver.Send(jtag_trans);
        config_count++;
        $fdisplay(file_desc,"%t: %m: Trans %d (sys_clk_switch):    Address to GC=%d, Data to GC=%d",  
                  $time, config_count, dut_ifc.cgra_cfg_addr, dut_ifc.cgra_cfg_wr_data);
        repeat(100) jtag_driver.Next_tck();
        repeat(200) begin
            jtag_driver.Next_tck();
            if(data_in==1)
                assert(top.dut.clk_out == top.dut.clk_in); //make sure we've actually switched to the fast clk;
            else if(data_in==0)
                assert(top.dut.clk_out == top.dut.tck); //make sure we've actually switched to the fast clk;
            end
    end
    endtask //switch clk
    
    task read_gc_reg(regfile_op_t op);
    begin
        gc_interface = jtag;
        jtag_trans.op = op;
        jtag_trans.data_out = 0;
        jtag_trans.done = 0;
        jtag_driver.Send(jtag_trans);
        jtag_trans = jtag_driver.GetResult();
        config_count++;
        $fdisplay(file_desc,"%t: %m: Trans %d (read_gc_reg):  Address to GC=%d, Data to GC=%d, Data out from GC=%d",  
                  $time, config_count, dut_ifc.cgra_cfg_addr, dut_ifc.cgra_cfg_wr_data, jtag_trans.data_out);
    end
    endtask //read_gc_reg
    
    task write_gc_reg(regfile_op_t op,int data_in);
    begin
        gc_interface = jtag;
        jtag_trans.op = op;
        jtag_trans.data_out = 0;
        jtag_trans.data_in = data_in;
        jtag_trans.done = 0;
        jtag_driver.Send(jtag_trans);
        config_count++;
        $fdisplay(file_desc,"%t: %m: Trans %d (write_gc_reg):  Address to GC=%d, Data to GC=%d, Data out from GC=%d",  
                  $time, config_count, dut_ifc.cgra_cfg_addr, dut_ifc.cgra_cfg_wr_data, jtag_trans.data_out);
    end
    endtask //write_gc_reg
 
    task write_glb_config(int addr, int data_in);
    begin
        gc_interface = jtag;
        state = glb_writing;
        jtag_trans.op = glb_write_config;
        jtag_trans.data_out = 0;
        jtag_trans.addr = addr;
        jtag_trans.data_in = data_in;
        jtag_trans.done = 0;
        jtag_driver.Send(jtag_trans);
        config_count++;
        $fdisplay(file_desc,"%t: %m: Trans %d (write_glb_config):  Address to GC=%d, Data to GC=%d, Data out from GC=%d",  
                  $time, config_count, dut_ifc.glb_cfg_wr_addr, dut_ifc.glb_cfg_wr_data, jtag_trans.data_out);
        state = other;
    end
    endtask //write_glb_config

    task read_glb_config(int addr);
    begin
        gc_interface = jtag;
        state = glb_reading;
        jtag_trans.op = glb_read_config;
        jtag_trans.addr = addr;
        jtag_trans.done = 0;
        dut_ifc.glb_cfg_rd_data = $urandom_range((2 ** `$config_data_width`)-1);
        dut_ifc.glb_cfg_rd_data_valid = 1;
        jtag_driver.Send(jtag_trans);
        dut_ifc.glb_cfg_rd_data_valid = 0;
        config_count++;
        jtag_trans = jtag_driver.GetResult();
        $fdisplay(file_desc,"%t: %m: Trans %d (read_glb_config):  Address to GC=%d, Data to GC=%d, Data from CGRA=%d, Data Read=%d",  
                  $time, config_count, dut_ifc.glb_cfg_rd_addr, dut_ifc.glb_cfg_wr_data, top.dut.glb_cfg_rd_data, jtag_trans.data_out);
        state = other;
    end
    endtask //read_glb_config
    
    task write_glb_sram_config(int addr, int data_in);
    begin
        gc_interface = jtag;
        state = sram_writing;
        jtag_trans.op = glb_sram_write_config;
        jtag_trans.data_out = 0;
        jtag_trans.addr = addr;
        jtag_trans.data_in = data_in;
        jtag_trans.done = 0;
        jtag_driver.Send(jtag_trans);
        config_count++;
        $fdisplay(file_desc,"%t: %m: Trans %d (write_glb_sram_config):  Address to GC=%d, Data to GC=%d, Data out from GC=%d",  
                  $time, config_count, dut_ifc.sram_cfg_wr_addr, dut_ifc.sram_cfg_wr_data, jtag_trans.data_out);
        state = other;
    end
    endtask //write_glb_sram_config

    task read_glb_sram_config(int addr);
    begin
        gc_interface = jtag;
        state = sram_reading;
        jtag_trans.op = glb_sram_read_config;
        jtag_trans.addr = addr;
        jtag_trans.done = 0;
        dut_ifc.sram_cfg_rd_data = $urandom_range((2 ** `$config_data_width`)-1);
        dut_ifc.sram_cfg_rd_data_valid = 1;
        jtag_driver.Send(jtag_trans);
        dut_ifc.sram_cfg_rd_data_valid = 0;
        config_count++;
        jtag_trans = jtag_driver.GetResult();
        $fdisplay(file_desc,"%t: %m: Trans %d (read_glb_sram_config):  Address to GC=%d, Data to GC=%d, Data from CGRA=%d, Data Read=%d",  
                  $time, config_count, dut_ifc.sram_cfg_rd_addr, dut_ifc.sram_cfg_wr_data, top.dut.sram_cfg_rd_data, jtag_trans.data_out);
        state = other;
    end
    endtask //read_glb_sram_config

    // task write_cgra_ctrl_reg(int addr, int data_in);
    // begin
    //     jtag_trans.op = cgra_ctrl_write;
    //     jtag_trans.data_out = 0;
    //     jtag_trans.addr = addr;
    //     jtag_trans.data_in = data_in;
    //     jtag_trans.done = 0;
    //     jtag_driver.Send(jtag_trans);
    //     config_count++;
    //     $fdisplay(file_desc,"%t: %m: Trans %d (write_cgra_ctrl_reg):  Address to GC=%d, Data to GC=%d, Data out from GC=%d",  
    //               $time, config_count, dut_ifc.cgra_cfg_addr, dut_ifc.cgra_cfg_wr_data, jtag_trans.data_out);
    // end
    // endtask //write_cgra_ctrl_reg

    // task read_cgra_ctrl_reg(int addr);
    // begin
    //     jtag_trans.op = cgra_ctrl_read;
    //     jtag_trans.addr = addr;
    //     jtag_trans.done = 0;
    //     jtag_driver.Send(jtag_trans);
    //     config_count++;
    //     jtag_trans = jtag_driver.GetResult();
    //     $fdisplay(file_desc,"%t: %m: Trans %d (read_cgra_ctrl_reg):  Address to GC=%d, Data to GC=%d, Data from CGRA=%d, Data Read=%d",  
    //               $time, config_count, dut_ifc.cgra_cfg_addr, dut_ifc.cgra_cfg_wr_data, top.dut.config_data_in, jtag_trans.data_out);
    //     state = other;
    // end
    // endtask //read_cgra_ctrl_reg

    // task axi_write_config(int addr, int data);
    // begin
    //     state = cgra_writing;
    //     config_count++;
    //     // first write to cgra_config_addr register
    //     axi_trans.addr = axi_cgra_config_addr;
    //     axi_trans.data_in = addr;
    //     axi_driver.axi_write(axi_trans.addr, axi_trans.data_in);

    //     axi_trans.addr = axi_cgra_config_data;
    //     axi_trans.data_in = data;
    //     axi_driver.axi_write(axi_trans.addr, axi_trans.data_in);
    //     axi_trans = axi_driver.GetResult();
    //     $fdisplay(file_desc,"%t: %m: Trans %d (AXI4 write):  Address to CGRA=%d, Data to CGRA=%d",  
    //         $time, config_count, dut_ifc.AWADDR, dut_ifc.WDATA);
    //     repeat (500) @(posedge dut_ifc.Clk); 
    //     state = other;
    // end
    // endtask

    // task axi_read_config(int addr, int data);
    // begin
    //     state = cgra_reading;
    //     config_count++;
    //     dut_ifc.cgra_cfg_rd_data = data; //$urandom_range((2 ** `$config_data_width`)-1);

    //     axi_trans.addr = axi_cgra_config_addr;
    //     axi_trans.data_in = addr;
    //     axi_driver.axi_write(axi_trans.addr, axi_trans.data_in);

    //     axi_trans.addr = axi_cgra_config_data;
    //     axi_driver.axi_read(axi_trans.addr);
    //     axi_trans = axi_driver.GetResult();
    //     $fdisplay(file_desc,"%t: %m: Trans %d (AXI4 Read):  Address to CGRA=%d, Data from CGRA=%d, Data Read=%d",  
    //         $time, config_count, dut_ifc.ARADDR, top.dut.config_data_in, axi_trans.data_out);
    //     repeat (500) @(posedge dut_ifc.Clk); 
    //     assert(top.dut.config_data_in == axi_trans.data_out);
    //     state = other;
    // end
    // endtask

    // task axi_write_glb_config(tile_id _tile, bit[3:0] _feature, bit[3:0] _reg, int data);
    // begin
    //     state = glb_writing;
    //     axi_trans.addr = {{_tile}, {_feature}, {_reg}, {2'b00}};
    //     axi_trans.data_in = data;
    //     config_count++;
    //     axi_driver.axi_write(axi_trans.addr, axi_trans.data_in);
    //     axi_trans = axi_driver.GetResult();
    //     $fdisplay(file_desc,"%t: %m: Trans %d (AXI4 glb write):  Address to CGRA=%d, Data to CGRA=%d",  
    //         $time, config_count, dut_ifc.AWADDR, dut_ifc.WDATA);
    //     repeat (500) @(posedge dut_ifc.Clk); 
    //     state = other;
    // end
    // endtask

    // task axi_read_glb_config(tile_id _tile, bit[3:0] _feature, bit[3:0] _reg, int data);
    // begin
    //     state = glb_reading;
    //     config_count++;
    //     dut_ifc.glb_cfg_rd_data = data; //$urandom_range((2 ** `$config_data_width`)-1);
    //     axi_trans.addr = {{_tile}, {_feature}, {_reg}, {2'b00}};
    //     axi_driver.axi_read(axi_trans.addr);
    //     axi_trans = axi_driver.GetResult();
    //     $fdisplay(file_desc,"%t: %m: Trans %d (AXI4 glb Read):  Address to CGRA=%d, Data from CGRA=%d, Data Read=%d",  
    //         $time, config_count, dut_ifc.ARADDR, top.dut.glb_config_data_in, axi_trans.data_out);
    //     repeat (500) @(posedge dut_ifc.Clk); 
    //     assert(top.dut.glb_config_data_in == axi_trans.data_out);
    //     state = other;
    // end
    // endtask

    // task axi_write_glb_sram_config(int addr, int data);
    // begin
    //     state = sram_writing;
    //     config_count++;
    //     axi_trans.addr = axi_glb_sram_config_addr;
    //     axi_trans.data_in = addr;
    //     axi_driver.axi_write(axi_trans.addr, axi_trans.data_in);

    //     axi_trans.addr = axi_glb_sram_config_data;
    //     axi_trans.data_in = data;
    //     axi_driver.axi_write(axi_trans.addr, axi_trans.data_in);
    //     axi_trans = axi_driver.GetResult();
    //     $fdisplay(file_desc,"%t: %m: Trans %d (AXI4 glb SRAM write):  Address to CGRA=%d, Data to CGRA=%d",  
    //         $time, config_count, dut_ifc.AWADDR, dut_ifc.WDATA);
    //     repeat (500) @(posedge dut_ifc.Clk); 
    //     state = other;
    // end
    // endtask

    // task axi_read_glb_sram_config(int addr, int data);
    // begin
    //     state = sram_reading;
    //     config_count++;
    //     dut_ifc.sram_cfg_rd_data = data; //$urandom_range((2 ** `$config_data_width`)-1);

    //     axi_trans.addr = axi_glb_sram_config_addr;
    //     axi_trans.data_in = addr;
    //     axi_driver.axi_write(axi_trans.addr, axi_trans.data_in);

    //     axi_trans.addr = axi_glb_sram_config_data;
    //     axi_driver.axi_read(axi_trans.addr);
    //     axi_trans = axi_driver.GetResult();
    //     $fdisplay(file_desc,"%t: %m: Trans %d (AXI4glb SRAM  Read):  Address to CGRA=%d, Data from CGRA=%d, Data Read=%d",  
    //         $time, config_count, dut_ifc.ARADDR, top.dut.glb_sram_config_data_in, axi_trans.data_out);
    //     assert(top.dut.glb_sram_config_data_in == axi_trans.data_out);
    //     repeat (500) @(posedge dut_ifc.Clk); 
    //     state = other;
    // end
    // endtask

    // task axi_write(int addr, int data);
    // begin
    //     config_count++;
    //     axi_trans.addr = addr;
    //     axi_trans.data_in = data;
    //     axi_driver.axi_write(axi_trans.addr, axi_trans.data_in);
    //     axi_trans = axi_driver.GetResult();
    //     $fdisplay(file_desc,"%t: %m: Trans %d (write_gc_reg):  Address to CGRA=%d, Data to CGRA=%d",  
    //         $time, config_count, dut_ifc.AWADDR, dut_ifc.WDATA);
    //     repeat (500) @(posedge dut_ifc.Clk); 
    //     state = other;
    // end
    // endtask

    // task axi_read(int addr);
    // begin
    //     config_count++;
    //     axi_trans.addr = addr;
    //     axi_driver.axi_read(axi_trans.addr);
    //     axi_trans = axi_driver.GetResult();
    //     $fdisplay(file_desc,"%t: %m: Trans %d (write_gc_reg):  Address to CGRA=%d, Data to CGRA=%d",  
    //         $time, config_count, dut_ifc.AWADDR, dut_ifc.WDATA);
    //     repeat (500) @(posedge dut_ifc.Clk); 
    //     state = other;
    // end
    // endtask

    task init_test();
    begin
        // read user input
        //ProcessArgs();
        rnd0 = $random(seed); // initial the random number generator
        
        // init the environment
        jtag_driver = new(jtag_ifc);
        jtag_driver.Zero();

        axi_driver = new(axi_ifc);
        axi_driver.Reset();
        
        //ZERO out any inputs to the DUT
        repeat (2) @(posedge dut_ifc.Clk); 
    end
    endtask // init_test

    task check_register(int register, int value);
        begin
            assert(top.dut.cgra_cfg_write == 0);
            assert(top.dut.cgra_cfg_read == 0);
            assert(register == value) else $display("reg: %d, val: %d",register,value);
        end
    endtask // check_register
 
endprogram : `mname`
    
