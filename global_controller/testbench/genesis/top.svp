/*************************************************************************
 ** From Perforce:
 **
 ** $Id: //Smart_design/ChipGen/moduleTest/Primitives/top.vp#5 $
 ** $DateTime: 2010/03/25 11:23:45 $
 ** $Change: 8474 $
 ** $Author: shacham $
 *************************************************************************/

/* *****************************************************************************
 * File: top.vp
 * Author: Ofer Shacham
 * 
 * Description:
 * simple top that instantiate the test and the dut
 * 
 *
 * Change bar:
 * -----------
 * Date          Author   Description
 * Mar 19, 2010  shacham  initial version
 *  
 * 
 * ****************************************************************************/

/*******************************************************************************
 * Generation Control Definitions
 ******************************************************************************/

/*******************************************************************************
 * Simulation Control Definitions
 ******************************************************************************/
//; my $max_cyc = parameter(Name=>'MaxCycles', Val=>100000, Min=>1, Step=>1, 
//;                Doc=>'Max number of simulation cycles');
//; my $design_name = parameter(Name=>'DesignName', Val=>'global_controller', 
//;                Doc=>'This is a generic top, so what is the design name to use?');
//; my $IDCODE = $self->define_param(IDCODE => 1);
//; my $cfg_data_width = parameter(Name=>'cfg_data_width',val=>32);
//; my $cfg_addr_width = parameter(Name=>'cfg_addr_width',val=>32);
//; my $axi_addr_width = parameter(Name=>'axi_addr_width',val=>12);
//; my $axi_data_width = parameter(NAME => 'axi_data_width', VAL => 32, DOC => 'Width of axi_data');
//; my $cfg_op_width = parameter(Name=>'cfg_op_width',val=>5);
//; my $block_axi_addr_width = parameter(NAME => 'block_axi_addr_width', VAL => 12, DOC => 'Width of axi_addr for sub block');
//; my $num_glb_tiles = parameter(NAME => 'num_glb_tiles', VAL => 16, DOC => 'number of global buffer tiles');
//; my $glb_addr_width = parameter(NAME => 'glb_addr_width', VAL => 22, DOC => 'Width of glb_addr');
//;
//; # Set up IO list for JTAG interface to pass to JTAGDriver 
//; my $io_list = $self->force_param(IO_LIST => 
//;        [    
//;            {name => 'trst_n', width => 1,  direction => 'in',  bsr => 'no',  pad => 'digital', orientation => 'right'},
//;            {name => 'tck', width => 1,  direction => 'in',  bsr => 'no',  pad => 'digital', orientation => 'right'},
//;            {name => 'tms', width => 1,  direction => 'in',  bsr => 'no',  pad => 'digital', orientation => 'right'},
//;            {name => 'tdi', width => 1,  direction => 'in',  bsr => 'no',  pad => 'digital', orientation => 'right'},
//;            {name => 'tdo', width => 1,  direction => 'out', bsr => 'no',  pad => 'digital', orientation => 'right'},
//;            {name => 'cgra_cfg_rd_data', width => $cfg_data_width,  direction => 'in', bsr => 'no',  pad => 'digital', orientation => 'right'},
//;            {name => 'cgra_cfg_wr_data', width => $cfg_data_width,  direction => 'out', bsr => 'no',  pad => 'digital', orientation => 'right'},
//;            {name => 'cgra_cfg_addr', width => $cfg_addr_width,  direction => 'out', bsr => 'no',  pad => 'digital', orientation => 'right'},
//;            {name => 'glb_cfg_rd_data', width => $axi_data_width,  direction => 'in', bsr => 'no',  pad => 'digital', orientation => 'right'},
//;            {name => 'glb_cfg_rd_data_valid', width => 1,  direction => 'in', bsr => 'no',  pad => 'digital', orientation => 'right'},
//;            {name => 'glb_cfg_rd_addr', width => $block_axi_addr_width,  direction => 'out', bsr => 'no',  pad => 'digital', orientation => 'right'},
//;            {name => 'glb_cfg_wr_data', width => $axi_data_width,  direction => 'out', bsr => 'no',  pad => 'digital', orientation => 'right'},
//;            {name => 'glb_cfg_wr_addr', width => $block_axi_addr_width,  direction => 'out', bsr => 'no',  pad => 'digital', orientation => 'right'},
//;            {name => 'sram_cfg_rd_data', width => $axi_data_width,  direction => 'in', bsr => 'no',  pad => 'digital', orientation => 'right'},
//;            {name => 'sram_cfg_rd_data_valid', width => 1,  direction => 'in', bsr => 'no',  pad => 'digital', orientation => 'right'},
//;            {name => 'sram_cfg_rd_addr', width => $glb_addr_width,  direction => 'out', bsr => 'no',  pad => 'digital', orientation => 'right'},
//;            {name => 'sram_cfg_wr_data', width => $axi_data_width,  direction => 'out', bsr => 'no',  pad => 'digital', orientation => 'right'},
//;            {name => 'sram_cfg_wr_addr', width => $glb_addr_width,  direction => 'out', bsr => 'no',  pad => 'digital', orientation => 'right'},
//;            {name => 'strm_start_pulse', width => $num_glb_tiles,  direction => 'out', bsr => 'no',  pad => 'digital', orientation => 'right'},
//;            {name => 'pc_start_pulse', width => $num_glb_tiles,  direction => 'out', bsr => 'no',  pad => 'digital', orientation => 'right'},
//;            {name => 'done_interrupt_pulse', width => 3*$num_glb_tiles,  direction => 'in', bsr => 'no',  pad => 'digital', orientation => 'right'},
//;            {name => 'awaddr', width => $axi_addr_width,  direction => 'in', bsr => 'no',  pad => 'digital', orientation => 'right'},
//;            {name => 'awvalid', width => 1,  direction => 'in', bsr => 'no',  pad => 'digital', orientation => 'right'},
//;            {name => 'awready', width => 1,  direction => 'out', bsr => 'no',  pad => 'digital', orientation => 'right'},
//;            {name => 'wdata', width => $axi_data_width,  direction => 'in', bsr => 'no',  pad => 'digital', orientation => 'right'},
//;            {name => 'wvalid', width => 1,  direction => 'in', bsr => 'no',  pad => 'digital', orientation => 'right'},
//;            {name => 'wready', width => 1,  direction => 'out', bsr => 'no',  pad => 'digital', orientation => 'right'},
//;            {name => 'bready', width => 1,  direction => 'in', bsr => 'no',  pad => 'digital', orientation => 'right'},
//;            {name => 'bvalid', width => 1,  direction => 'out', bsr => 'no',  pad => 'digital', orientation => 'right'},
//;            {name => 'bresp', width => 2,  direction => 'out', bsr => 'no',  pad => 'digital', orientation => 'right'},
//;            {name => 'araddr', width => $axi_addr_width,  direction => 'in', bsr => 'no',  pad => 'digital', orientation => 'right'},
//;            {name => 'arvalid', width => 1,  direction => 'in', bsr => 'no',  pad => 'digital', orientation => 'right'},
//;            {name => 'arready', width => 1,  direction => 'out', bsr => 'no',  pad => 'digital', orientation => 'right'},
//;            {name => 'rdata', width => $axi_data_width,  direction => 'out', bsr => 'no',  pad => 'digital', orientation => 'right'},
//;            {name => 'rvalid', width => 1,  direction => 'out', bsr => 'no',  pad => 'digital', orientation => 'right'},
//;            {name => 'rready', width => 1,  direction => 'in', bsr => 'no',  pad => 'digital', orientation => 'right'},
//;            {name => 'rresp', width => 2,  direction => 'in', bsr => 'no',  pad => 'digital', orientation => 'right'}
//;        ]);
//; my $num_ios = scalar(@{$io_list});

//; my $sc_jtag2gc_ifc = $self->unique_inst('cfg_ifc', 'sc_jtag2gc_ifc',
//;                                          DataWidth => $cfg_data_width,
//;                                          AddrWidth => $cfg_addr_width,
//;                                          OpcodeWidth => $cfg_op_width);
//; my $sc_cfg_ifc_ref = parameter(name=>'SC_CFG_IFC_REF',val=>$sc_jtag2gc_ifc);
//; my $tc_cfg_ifc_ref = parameter(name=>'TC_CFG_IFC_REF',val=>$sc_jtag2gc_ifc);

/*******************************************************************************
 * Module top:
 ******************************************************************************/

module `mname`();
   logic Clk;
   logic Reset;

   /****************************************************************************
    * Instantiate clocks
    * *************************************************************************/
    //; my $clocker_obj = generate('clocker', 'clocker', CLK_PERIOD=>10, RST_PERIOD=>20);
    `$clocker_obj->instantiate` (.Clk(Clk), .tck(tck), .Reset(Reset));

   // timer:
   initial begin
      repeat(`$max_cyc`) @(posedge Clk);
      $display("\n%0t\tERROR: The `$max_cyc` cycles marker has passed!",$time);
      $finish(2);
   end

   /****************************************************************************
    * Instantiate DUT interface and DUT
    * *************************************************************************/
   //; # We use generate_base when there is for sure just one of X
   //; my $dut_ifc = $self->unique_inst('template_ifc', 'dut_ifc', IO_LIST=>$io_list);
   `$dut_ifc->instantiate` (.Clk(Clk), .Reset(Reset));

   //; my $dut_obj = generate_base($design_name, 'dut', cfg_data_width=>$cfg_data_width,cfg_addr_width=>$cfg_addr_width,cfg_op_width=>$cfg_op_width,
   //;                              axi_data_width=>$axi_data_width, axi_addr_width=>$axi_addr_width, num_glb_tiles=>$num_glb_tiles, block_axi_addr_width=>$block_axi_addr_width);
   //; # my $jtag_ifc = $self->unique_inst('jtag_ifc', 'jtag_ifc');
   //; # my $axil_ifc = $self->unique_inst('axil_ifc', 'axil_ifc');

   //; # $self -> define_param(JTAG_IFC => $jtag_ifc);
   //; # $self -> define_param(AXIL_IFC => $axil_ifc);
   //; $self -> define_param(DUT_IFC => $dut_ifc);

   //; #`$jtag_ifc->instantiate` ();
   //; #`$axil_ifc->instantiate` (.clk(Clk));
   `$dut_obj->instantiate` ();

   //Since we aren't using interface here, assign singals 
   // clk and reset
   assign dut.clk_in = dut_ifc.Clk;
   assign dut.reset_in = dut_ifc.Reset;

   // JTAG
   assign dut.tck = dut_ifc.tck;
   assign dut.trst_n = dut_ifc.trst_n;
   assign dut.tdi = dut_ifc.tdi;
   assign dut.tms = dut_ifc.tms;
   assign dut_ifc.tdo = dut.tdo;

   // axi 
   assign dut.axi_awaddr = dut_ifc.awaddr;
   assign dut.axi_awvalid = dut_ifc.awvalid;
   assign dut.axi_wdata = dut_ifc.wdata;
   assign dut.axi_wvalid = dut_ifc.wvalid;
   assign dut.axi_bready = dut_ifc.bready;
   assign dut.axi_araddr = dut_ifc.araddr;
   assign dut.axi_arvalid = dut_ifc.arvalid;
   assign dut.axi_rready = dut_ifc.rready;
   assign dut_ifc.awready = dut.axi_awready;
   assign dut_ifc.wready = dut.axi_wready;
   assign dut_ifc.bvalid = dut.axi_bvalid;
   assign dut_ifc.bresp = dut.axi_bresp;
   assign dut_ifc.rdata = dut.axi_rdata;
   assign dut_ifc.rvalid = dut.axi_rvalid;
   assign dut_ifc.arready = dut.axi_arready;
   assign dut_ifc.rresp = dut.axi_rresp;

   // cgra ifc
   assign dut_ifc.cgra_cfg_addr = dut.cgra_cfg_addr;
   assign dut_ifc.cgra_cfg_wr_data = dut.cgra_cfg_wr_data;
   assign dut.cgra_cfg_rd_data = dut_ifc.cgra_cfg_rd_data;

   // glb ifc
   assign dut_ifc.glb_cfg_wr_addr = dut.glb_cfg_wr_addr;
   assign dut_ifc.glb_cfg_wr_data = dut.glb_cfg_wr_data;
   assign dut_ifc.glb_cfg_rd_addr = dut.glb_cfg_rd_addr;
   assign dut.glb_cfg_rd_data = dut_ifc.glb_cfg_rd_data;
   assign dut.glb_cfg_rd_data_valid = dut_ifc.glb_cfg_rd_data_valid;

   // sram ifc
   assign dut_ifc.sram_cfg_wr_addr = dut.sram_cfg_wr_addr;
   assign dut_ifc.sram_cfg_wr_data = dut.sram_cfg_wr_data;
   assign dut_ifc.sram_cfg_rd_addr = dut.sram_cfg_rd_addr;
   assign dut.sram_cfg_rd_data = dut_ifc.sram_cfg_rd_data;
   assign dut.sram_cfg_rd_data_valid = dut_ifc.sram_cfg_rd_data_valid;

   /****************************************************************************
    * Instantiate Test
    * **************************************************************************/
    //; my $tst_obj = generate('glc_prog', 'tst');
    `$tst_obj->instantiate` (.ifc(`$dut_ifc->iname()`));
      
endmodule
 
