//
//--------------------------------------------------------------------------------
//          THIS FILE WAS AUTOMATICALLY GENERATED BY THE GENESIS2 ENGINE        
//  FOR MORE INFORMATION: OFER SHACHAM (CHIP GENESIS INC / STANFORD VLSI GROUP)
//    !! THIS VERSION OF GENESIS2 IS NOT FOR ANY COMMERCIAL USE !!
//     FOR COMMERCIAL LICENSE CONTACT SHACHAM@ALUMNI.STANFORD.EDU
//--------------------------------------------------------------------------------
//
//  
//	-----------------------------------------------
//	|            Genesis Release Info             |
//	|  $Change: 11904 $ --- $Date: 2013/08/03 $   |
//	-----------------------------------------------
//	
//
//  Source file: /aha/garnet/global_controller/rtl/genesis/cfg_and_dbg.svp
//  Source template: cfg_and_dbg
//
// --------------- Begin Pre-Generation Parameters Status Report ---------------
//
//	From 'generate' statement (priority=5):
// Parameter SC_CFG_OPCODES 	= Data structure of type HASH
// Parameter SC_CFG_BUS 	= yes
// Parameter sc_cfg_addr_width 	= 32
// Parameter TC_CFG_BUS 	= no
// Parameter sc_cfg_bus_width 	= 32
// Parameter sc_cfg_op_width 	= 5
//
//		---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ----
//
//	From Command Line input (priority=4):
//
//		---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ----
//
//	From XML input (priority=3):
//
//		---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ----
//
//	From Config File input (priority=2):
//
// ---------------- End Pre-Generation Pramameters Status Report ----------------

/* *****************************************************************************
 * File: cfg_and_dbg.vp
 * Author: Ofer Shacham
 * 
 * Description:
 * This module is used as the top of the JTAG accessed logic. It contains the 
 * tap as well as controllers for the boundary scan register and optionally
 * controllers for a reg-file chain which can be either on system clock or/and 
 * on JTAG clock.
 * 
 * The cfg and dbg module assumes that upon reads, the user knows that he/she
 * needs to wait for the data to arrive from the reg-file array, and would
 * add delay cycles as needed between loading the instruction and address to 
 * reading the data. 
 * 
 * REQUIRED GENESIS PARAMETERS:
 * ----------------------------
 * For the sys-clock domain ports
 * * SC_CFG_IFC_REF - An instance of the cfg_ifc (used as reference)
 * * SC_CFG_BUS - on/off or yes/no switch for the system clock domain config bus
 * * SC_CFG_OPCODES - Interpretation of the opcode. Must contain the following feilds:
 *    * nop - value of cfg2rf_op for a no-op (default is 0)
 *    * read - value of cfg2rf_op for a read operation (default is 1)
 *    * write - value of cfg2rf_op for a write operation (default is 2)
 *    * bypass - value of cfg2rf_op for bypassing the control signals (default is 3)
 * 
 * For the tck domain ports
 * * TC_CFG_IFC_REF - An instance of the cfg_ifc (used as reference)
 * * TC_CFG_BUS - on/off or yes/no switch for the jtag tck domain config bus
 * * TC_CFG_OPCODES - Interpretation of the opcode. Must contain the following feilds:
 *    * nop - value of cfg2rf_op for a no-op (default is 0)
 *    * read - value of cfg2rf_op for a read operation (default is 1)
 *    * write - value of cfg2rf_op for a write operation (default is 2)
 *    * bypass - value of cfg2rf_op for bypassing the control signals (default is 3)
 * 
 * 
 * Inputs:
 * -------
 * 
 * Outputs:
 * --------
 * 
 * Change bar:
 * -----------
 * Date          Author   Description
 * Mar 28, 2010  shacham  init version  --  
 * May 24, 2010  shacham  Replaced config bus signals and parameters with an 
 *			  interface. 
 * Apr 18, 2012  shacham  clean up of names and genesis syntactic sugar
 * May 20, 2014  jingpu   fixed legacy verilog syntax and fix idcode
 * ****************************************************************************/

// ACTUAL GENESIS2 PARAMETERIZATIONS
// SC_CFG_BUS (_GENESIS2_INHERITANCE_PRIORITY_) = yes
//
// SC_CFG_OPCODES (_GENESIS2_INHERITANCE_PRIORITY_) = 
//	{ adv_clk=>11, axi_read=>23, axi_write=>22, bypass=>3, glb_rd_config=>19, glb_sram_read_config=>21, glb_sram_write_config=>20, glb_wr_config=>18, 
//	  global_reset=>7, nop=>0, rd_TST=>6, rd_delay_sel_reg=>17, rd_rd_delay_reg=>15, read=>2, read_clk_domain=>12, read_glb_stall=>25, 
//	  read_stall=>10, switch_clk=>13, wr_A050=>4, wr_delay_sel_reg=>16, wr_rd_delay_reg=>14, wr_to_TST=>5, write=>1, write_glb_stall=>24, 
//	  write_stall=>9 }
//
// sc_cfg_bus_width (_GENESIS2_INHERITANCE_PRIORITY_) = 32
//
// sc_cfg_addr_width (_GENESIS2_INHERITANCE_PRIORITY_) = 32
//
// sc_cfg_op_width (_GENESIS2_INHERITANCE_PRIORITY_) = 5
//
// TC_CFG_BUS (_GENESIS2_INHERITANCE_PRIORITY_) = no
//
// TC_CFG_OPCODES (_GENESIS2_DECLARATION_PRIORITY_) = 
//	{ bypass=>3, nop=>0, read=>1, write=>2 }
//
// tc_cfg_bus_width (_GENESIS2_DECLARATION_PRIORITY_) = 32
//
// tc_cfg_addr_width (_GENESIS2_DECLARATION_PRIORITY_) = 32
//
// tc_cfg_op_width (_GENESIS2_DECLARATION_PRIORITY_) = 5
//


module cfg_and_dbg_unq1
  (
   // Signals for a system clked configuration bus
   output [31:0] sc_cfgReq_addr,
   output [31:0] sc_cfgReq_data,
   output [4:0] sc_cfgReq_op,
   
   input [31:0] sc_cfgRep_addr,
   input [31:0] sc_cfgRep_data,
   input [4:0] sc_cfgRep_op,

   // system clock and reset
   input                                Clk,
   input             	                Reset,
   
   // Signals for a jtag clked configuration bus
 
   // Signals for the Boundary Scan Register
    output 				logic bsr_tdi,
    output 				logic bsr_sample,
    output 				logic bsr_intest,
    output 				logic bsr_extest,
    output 				logic bsr_update_en,
    output 				logic bsr_capture_en,
    output 				logic bsr_shift_dr,
    input 				bsr_tdo,

    //Is global controller running on sys clk? or still on test clk?
    input	 sys_clk_activated,


    input        tms,          	// JTAG Test Mode Select
    input        tck,          	// JTAG Test Clock
    input        trst_n,         // JTAG Test Reset
    input        tdi,          	// JTAG Test Data Input
    output       tdo,	      	// JTAG Test Data Output
    output       tdo_en	        // JTAG Test Data Output
    );

   // reset signal for jtag domain registers
   wire 	  test_logic_reset;
   

   // Signals comming from the tap for the special instructions
   // for the sys-clock config bus
   // sc_cfg_data
   wire 	  sc_cfg_data_capture_dr;		
   wire 	  sc_cfg_data_shift_dr;			
   wire 	  sc_cfg_data_update_dr;		
   wire 	  sc_cfg_data_tdo;
   // sc_cfg_inst				
   wire 	  sc_cfg_inst_capture_dr;		
   wire 	  sc_cfg_inst_shift_dr;			
   wire 	  sc_cfg_inst_update_dr;		
   wire 	  sc_cfg_inst_tdo;
   // sc_cfg_addr				
   wire 	  sc_cfg_addr_capture_dr;		
   wire 	  sc_cfg_addr_shift_dr;			
   wire 	  sc_cfg_addr_update_dr;		
   wire 	  sc_cfg_addr_tdo;

   // for the jtag-clock config bus

   // Instantiate the Test Access Port (TAP)
   tap_unq1 tap 
     (
      // JTAG signals
      .tms(tms),
      .tck(tck),
      .trst_n(trst_n),
      .tdi(tdi),
      .tdo(tdo),
      .tdo_en(tdo_en),
      
      // sc_cfg_data
      .sc_cfg_data_capture_dr(sc_cfg_data_capture_dr),		
      .sc_cfg_data_shift_dr(sc_cfg_data_shift_dr),			
      .sc_cfg_data_update_dr(sc_cfg_data_update_dr),		
      .sc_cfg_data_tdo(sc_cfg_data_tdo),
				
      // sc_cfg_inst				
      .sc_cfg_inst_capture_dr(sc_cfg_inst_capture_dr),		
      .sc_cfg_inst_shift_dr(sc_cfg_inst_shift_dr),			
      .sc_cfg_inst_update_dr(sc_cfg_inst_update_dr),		
      .sc_cfg_inst_tdo(sc_cfg_inst_tdo),
      						
      // sc_cfg_addr				
      .sc_cfg_addr_capture_dr(sc_cfg_addr_capture_dr),		
      .sc_cfg_addr_shift_dr(sc_cfg_addr_shift_dr),			
      .sc_cfg_addr_update_dr(sc_cfg_addr_update_dr),		
      .sc_cfg_addr_tdo(sc_cfg_addr_tdo),
      						
      .test_logic_reset(test_logic_reset),

      
      // BSR interface
      .bsr_extest(bsr_extest),
      .bsr_intest(bsr_intest),
      .bsr_sample(bsr_sample),
      .bsr_capture_en(bsr_capture_en),
      .bsr_shift_dr(bsr_shift_dr),
      .bsr_update_en(bsr_update_en),
      .bsr_tdo(bsr_tdo)
      );
   


   /************ Logic for controlling the system-clock config bus ************/
   // Since this cfg interface is all on the system clock, life is more
   // interesting. We need to cross domains by qualifying the output signals.
   // * Since outputs are only considered when the instruction is meanningful--
   //   we'll qualify the sc_cfgReq.op by creating a qualified update signal.
   // * JTAG only samples the input after the read completed. We already
   // assumed (see header) that the frequency of jtag ops is lower then it takes
   // to go through the chain of reg-files.
   /***************************************************************************/
   // shift in/out the instuction
   wire [4:0] sc_inst;
   flop_unq1 sc_inst_reg 
     (.dout(sc_inst),	.din({tdi, sc_inst[4:1]}),
      .Clk(tck),	.en(sc_cfg_inst_shift_dr),      .Reset(test_logic_reset));

   // Qualify the instruction
   wire [3:0] inst_update_qual;
   wire       inst_update_qualified;
   assign inst_update_qualified = ((sys_clk_activated & inst_update_qual==4'b1110) | (!sys_clk_activated & inst_update_qual[3]==1)) ? 1'b1:1'b0;
   flop_unq2 inst_update_reg 
     (.dout(inst_update_qual),	.din({sc_cfg_inst_update_dr, inst_update_qual[3:1]}),
      .Clk(Clk),	.Reset(Reset));
   

   // assign transaction to the bus on update (pulse)
   assign 			   sc_cfgReq_op = (inst_update_qualified) ? 
						   sc_inst : 5'd0;
   // assign tdo with instruction always
   assign 			   sc_cfg_inst_tdo = sc_inst[0];
   //*******

   
   //*******
   // shift in/out the address
   wire [31:0] sc_addr;
   flop_unq3  sc_addr_reg 
     (.dout(sc_addr),	.din({tdi, sc_addr[31:1]}),
      .Clk(tck),	.en(sc_cfg_addr_shift_dr),      .Reset(test_logic_reset));

   // assign bus / tdo with address (always)
   assign 			     sc_cfgReq_addr = sc_addr;
   assign 			     sc_cfg_addr_tdo = sc_addr[0];
   //*******


   //*******
   // register for the received data until the jtag interface asks for it
   wire [31:0] sc_data_rd;
   wire 			   sc_data_rd_en;
   assign 			   sc_data_rd_en = (sc_cfgRep_op == 5'd3)? 
						   1'b1: 1'b0;
   flop_unq3 sc_data_rd_reg 
     (.dout(sc_data_rd),	.din(sc_cfgRep_data),
      .Clk(Clk),	.en(sc_data_rd_en),      
      .Reset(Reset));
   //*******

   
   //*******
   // shift in/out the data
   wire [31:0] sc_data;
   wire [31:0] sc_data_nxt;
   assign 			     sc_data_nxt = (sc_cfg_data_capture_dr) ? 
						    sc_data_rd : {tdi, sc_data[31:1]};
   
   flop_unq3 sc_data_reg 
     (.dout(sc_data),	.din(sc_data_nxt),
      .Clk(tck),	.en(sc_cfg_data_shift_dr | sc_cfg_data_capture_dr),      
      .Reset(test_logic_reset));

   // assign bus / tdo with data (always)
   assign 			     sc_cfgReq_data = sc_data;
   assign sc_cfg_data_tdo = sc_data[0];
   //*******

   
   /***************************************************************************/

   

endmodule // cfg_and_dbg_unq1
