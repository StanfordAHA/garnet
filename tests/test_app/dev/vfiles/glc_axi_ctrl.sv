//
//--------------------------------------------------------------------------------
//          THIS FILE WAS AUTOMATICALLY GENERATED BY THE GENESIS2 ENGINE        
//  FOR MORE INFORMATION: OFER SHACHAM (CHIP GENESIS INC / STANFORD VLSI GROUP)
//    !! THIS VERSION OF GENESIS2 IS NOT FOR ANY COMMERCIAL USE !!
//     FOR COMMERCIAL LICENSE CONTACT SHACHAM@ALUMNI.STANFORD.EDU
//--------------------------------------------------------------------------------
//
//  
//	-----------------------------------------------
//	|            Genesis Release Info             |
//	|  $Change: 11904 $ --- $Date: 2013/08/03 $   |
//	-----------------------------------------------
//	
//
//  Source file: /aha/garnet/global_controller/rtl/genesis/glc_axi_ctrl.svp
//  Source template: glc_axi_ctrl
//
// --------------- Begin Pre-Generation Parameters Status Report ---------------
//
//	From 'generate' statement (priority=5):
// Parameter axi_addr_width 	= 13
// Parameter block_axi_addr_width 	= 12
// Parameter axi_data_width 	= 32
// Parameter num_glb_tiles 	= 4
//
//		---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ----
//
//	From Command Line input (priority=4):
//
//		---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ----
//
//	From XML input (priority=3):
//
//		---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ----
//
//	From Config File input (priority=2):
//
// ---------------- End Pre-Generation Pramameters Status Report ----------------

/*=============================================================================
** Module: glc_axi_ctrl.svp
** Description:
**              Global Controller AXI Controller
** Author: Taeyoung Kong
** Change history: 04/10/2020
**      - Initial version
**===========================================================================*/

//============================================================================//
// Genesis parameter declaration
//============================================================================//
// axi_addr_width (_GENESIS2_INHERITANCE_PRIORITY_) = 13
//
// axi_data_width (_GENESIS2_INHERITANCE_PRIORITY_) = 32
//
// block_axi_addr_width (_GENESIS2_INHERITANCE_PRIORITY_) = 12
//
// num_glb_tiles (_GENESIS2_INHERITANCE_PRIORITY_) = 4
//

module glc_axi_ctrl(
    input  logic                                clk,
    input  logic                                reset,

    // axi4-lite slave interface
    input  logic [12:0]        axi_awaddr,
    input  logic                                axi_awvalid,
    output logic                                axi_awready,
    input  logic [31:0]        axi_wdata,
    input  logic                                axi_wvalid,
    output logic                                axi_wready,
    input  logic                                axi_bready,
    output logic [1:0]                          axi_bresp,
    output logic                                axi_bvalid,
    input  logic [12:0]        axi_araddr,
    input  logic                                axi_arvalid,
    output logic                                axi_arready,
    output logic [31:0]        axi_rdata,
    output logic [1:0]                          axi_rresp,
    output logic                                axi_rvalid,
    input  logic                                axi_rready,

    // global buffer configuration
    output logic                                axi_glb_cfg_wr_en,
    output logic                                axi_glb_cfg_wr_clk_en,
    output logic [11:0]  axi_glb_cfg_wr_addr,
    output logic [31:0]        axi_glb_cfg_wr_data,
    output logic                                axi_glb_cfg_rd_en,
    output logic                                axi_glb_cfg_rd_clk_en,
    output logic [11:0]  axi_glb_cfg_rd_addr,
    input  logic [31:0]        axi_glb_cfg_rd_data,
    input  logic                                axi_glb_cfg_rd_data_valid,

    // global controller configuration
    output logic                                axi_glc_cfg_wr_en,
    output logic                                axi_glc_cfg_wr_clk_en,
    output logic [11:0]  axi_glc_cfg_wr_addr,
    output logic [31:0]        axi_glc_cfg_wr_data,
    output logic                                axi_glc_cfg_rd_en,
    output logic                                axi_glc_cfg_rd_clk_en,
    output logic [11:0]  axi_glc_cfg_rd_addr,
    input  logic [31:0]        axi_glc_cfg_rd_data,
    input  logic                                axi_glc_cfg_rd_data_valid
);

//============================================================================//
// Enum states
//============================================================================//
typedef enum logic[2:0] {
    RD_IDLE = 3'h0,
    RD_REQ_GLC = 3'h1,
    RD_REQ_GLB = 3'h2,
    RD_WAIT = 3'h3,
    RD_RESP = 3'h4
} RdState;
RdState rd_state;

typedef enum logic[2:0] {
    WR_IDLE = 3'h0,
    WR_REQ_GLC = 3'h1,
    WR_REQ_GLB = 3'h2,
    WR_WAIT = 3'h3,
    WR_RESP = 3'h4
} WrState;
WrState wr_state;


//============================================================================//
// internal wires
//============================================================================//
logic [$clog2(14):0] wr_wait_cnt;
logic cfg_rd_is_glb;

logic cfg_wr_glb_clk_en;
logic cfg_rd_glb_clk_en;
logic cfg_wr_glc_clk_en;
logic cfg_rd_glc_clk_en;

// timeout
// local parameter
localparam bit[9:0] MAX_TIME_CNT = 1023;
logic [9:0] rd_timeout_cnt;
logic [9:0] wr_timeout_cnt;

//============================================================================//
// write FSM
//============================================================================//
always_ff @(posedge clk or posedge reset) begin
    if (reset) begin
        wr_state <= WR_IDLE;
        wr_wait_cnt <= 0;
        cfg_wr_glb_clk_en <= 0;
        cfg_wr_glc_clk_en <= 0;

        // axi interface
        axi_awready <= '1;
        axi_wready <= '0;
        axi_bresp <= 2'b00;
        axi_bvalid <= '0;

        // glc cfg interface
        axi_glc_cfg_wr_en <= '0;
        axi_glc_cfg_wr_data <= '0;
        axi_glc_cfg_wr_addr <= '0;

        // glb cfg interface
        axi_glb_cfg_wr_en <= '0;
        axi_glb_cfg_wr_data <= '0;
        axi_glb_cfg_wr_addr <= '0;

        // timeout cnt
        wr_timeout_cnt <= MAX_TIME_CNT;
    end
    else if (wr_state == WR_IDLE) begin
        // clock gating
        cfg_wr_glb_clk_en <= 0;
        cfg_wr_glc_clk_en <= 0;

        // axi interface
        axi_awready <= '1;
        axi_wready <= '0;
        axi_bresp <= 2'b00;
        axi_bvalid <= '0;

        // glc cfg interface
        axi_glc_cfg_wr_en <= '0;
        axi_glc_cfg_wr_data <= '0;
        axi_glc_cfg_wr_addr <= '0;

        // glb cfg interface
        axi_glb_cfg_wr_en <= '0;
        axi_glb_cfg_wr_data <= '0;
        axi_glb_cfg_wr_addr <= '0;

        // timeout cnt
        wr_timeout_cnt <= MAX_TIME_CNT;

        if (axi_awvalid & axi_awready) begin
            // awready to 0, wready to 1
            axi_awready <= 1'h0;
            axi_wready <= 1'h1;

            if (axi_awaddr[12] == 1'b0) begin
                wr_state <= WR_REQ_GLC;
                // cfg glc clock gating off
                cfg_wr_glc_clk_en <= 1;
                axi_glc_cfg_wr_addr <= axi_awaddr;
            end
            else begin
                wr_state <= WR_REQ_GLB;
                // cfg glb clock gating off
                cfg_wr_glb_clk_en <= 1;
                axi_glb_cfg_wr_addr <= axi_awaddr[11:0];
            end
        end
        else if (axi_awvalid) begin
            axi_awready <= 1'h1;
        end
    end
    else if (wr_state == WR_REQ_GLC) begin
        if (axi_wvalid & axi_wready) begin
            axi_wready <= 1'h0;
            axi_glc_cfg_wr_en <= 1'h1;
            axi_glc_cfg_wr_data <= axi_wdata;
            wr_wait_cnt <= 'd0;
            wr_state <= WR_WAIT;
        end
    end
    else if (wr_state == WR_REQ_GLB) begin
        if (axi_wvalid & axi_wready) begin
            axi_wready <= 1'h0;
            axi_glb_cfg_wr_en <= 1'h1;
            axi_glb_cfg_wr_data <= axi_wdata;
            wr_wait_cnt <= 14;
            wr_state <= WR_WAIT;
        end
    end
    else if (wr_state == WR_WAIT) begin
        axi_glc_cfg_wr_en <= 1'h0;
        axi_glb_cfg_wr_en <= 1'h0;
        axi_glc_cfg_wr_addr <= '0;
        axi_glb_cfg_wr_addr <= '0;
        axi_glc_cfg_wr_data <= '0;
        axi_glb_cfg_wr_data <= '0;
        if (wr_wait_cnt == '0) begin
            axi_bvalid <= 1'h1;
            axi_bresp <= 2'b00;
            wr_state <= WR_RESP;
        end
        else begin
            wr_wait_cnt <= wr_wait_cnt - 1;
        end
    end
    else if (wr_state == WR_RESP) begin
        // cfg clock gating on again
        cfg_wr_glb_clk_en <= 0;
        cfg_wr_glc_clk_en <= 0;
        if (axi_bready & axi_bvalid) begin
            axi_bvalid <= 1'h0;
            wr_state <= WR_IDLE;
        end
        else if (wr_timeout_cnt == 0) begin
            axi_bvalid <= 1'h0;
            wr_state <= WR_IDLE;
        end
        else begin
            wr_timeout_cnt <= wr_timeout_cnt -1;
        end
    end
end

//============================================================================//
// read fsm
//============================================================================//
always_ff @(posedge clk or posedge reset) begin
    if (reset) begin
        rd_state <= RD_IDLE;
        cfg_rd_is_glb <= '0;

        // clock gating on
        cfg_rd_glb_clk_en <= 0;
        cfg_rd_glc_clk_en <= 0;

        // axi interface
        axi_arready <= 1'h1;
        axi_rresp <= 2'b00;
        axi_rdata <= '0;

        // glc interface
        axi_glc_cfg_rd_en <= 1'h0;
        axi_glc_cfg_rd_addr <= '0;
        
        // glb interface
        axi_glb_cfg_rd_en <= 1'h0;
        axi_glb_cfg_rd_addr <= '0;

        // timeout counter
        rd_timeout_cnt <= MAX_TIME_CNT;
    end
    else if (rd_state == RD_IDLE) begin
        // clock gating on
        cfg_rd_glb_clk_en <= 0;
        cfg_rd_glc_clk_en <= 0;

        // axi interface
        axi_arready <= 1'h1;
        axi_rresp <= 2'b00;
        axi_rvalid <= 1'h0;

        // glc interface
        axi_glc_cfg_rd_en <= 1'h0;
        axi_glc_cfg_rd_addr <= '0;

        // glb interface
        axi_glb_cfg_rd_en <= 1'h0;
        axi_glb_cfg_rd_addr <= '0;

        // timeout counter
        rd_timeout_cnt <= MAX_TIME_CNT;

        if (axi_arvalid & axi_arready) begin
            axi_arready <= 1'h0;
            if (axi_araddr[12] == 1'b0) begin
                // cfg glc clock gating off
                cfg_rd_glc_clk_en <= 1;

                rd_state <= RD_REQ_GLC;
                axi_glc_cfg_rd_addr <= axi_araddr;
            end
            else begin
                // cfg glb clock gating off
                cfg_rd_glb_clk_en <= 1;

                rd_state <= RD_REQ_GLB;
                axi_glb_cfg_rd_addr <= axi_araddr[11:0];
            end
        end
        else if (axi_arvalid) begin
            axi_arready <= 1'h1;
        end
    end
    else if (rd_state == RD_REQ_GLC) begin
        axi_glc_cfg_rd_en <= 1'h1;
        rd_state <= RD_WAIT;
        cfg_rd_is_glb <= '0;
        rd_timeout_cnt <= MAX_TIME_CNT;
    end
    else if (rd_state == RD_REQ_GLB) begin
        axi_glb_cfg_rd_en <= 1'h1;
        rd_state <= RD_WAIT;
        cfg_rd_is_glb <= '1;
        rd_timeout_cnt <= MAX_TIME_CNT;
    end
    else if (rd_state == RD_WAIT) begin
        if (cfg_rd_is_glb) begin
            axi_glb_cfg_rd_en <= 1'h0;
            axi_glb_cfg_rd_addr <= '0;
            if (axi_glb_cfg_rd_data_valid == 1'b1) begin
                axi_rdata <= axi_glb_cfg_rd_data;
                axi_rvalid <= 1'h1;
                axi_rresp <= 2'b00;
                rd_timeout_cnt <= MAX_TIME_CNT;
                rd_state <= RD_RESP;
            end
            else if (rd_timeout_cnt == 0) begin
                axi_rdata <= axi_glb_cfg_rd_data;
                axi_rvalid <= 1'h1;
                axi_rresp <= 2'b10;
                rd_timeout_cnt <= MAX_TIME_CNT;
                rd_state <= RD_RESP;
            end
            else begin
                rd_timeout_cnt <= rd_timeout_cnt - 1;
            end
        end
        else begin
            axi_glc_cfg_rd_en <= 1'h0;
            axi_glc_cfg_rd_addr <= '0;
            if (axi_glc_cfg_rd_data_valid == 1'b1) begin
                axi_rdata <= axi_glc_cfg_rd_data;
                axi_rvalid <= 1'h1;
                axi_rresp <= 2'b00;
                rd_timeout_cnt <= MAX_TIME_CNT;
                rd_state <= RD_RESP;
            end
            else if (rd_timeout_cnt == 0) begin
                axi_rdata <= axi_glc_cfg_rd_data;
                axi_rvalid <= 1'h1;
                axi_rresp <= 2'b10;
                rd_timeout_cnt <= MAX_TIME_CNT;
                rd_state <= RD_RESP;
            end
            else begin
                rd_timeout_cnt <= rd_timeout_cnt - 1;
            end
        end
    end
    else if (rd_state == RD_RESP) begin
        cfg_rd_glb_clk_en <= 0;
        cfg_rd_glc_clk_en <= 0;
        if (axi_rready & axi_rvalid) begin
            axi_rresp <= 2'b00;
            axi_rvalid <= 1'h0;
            rd_state <= RD_IDLE;
        end
        else if (rd_timeout_cnt == 0) begin

            axi_rresp <= 2'b10;
            axi_rvalid <= 1'h0;
            rd_state <= RD_IDLE;
        end
        else begin
            rd_timeout_cnt <= rd_timeout_cnt - 1;
        end
    end
end

//============================================================================//
// assign clk_en
//============================================================================//
assign axi_glb_cfg_wr_clk_en = cfg_wr_glb_clk_en;
assign axi_glc_cfg_wr_clk_en = cfg_wr_glc_clk_en;
assign axi_glb_cfg_rd_clk_en = cfg_rd_glb_clk_en;
assign axi_glc_cfg_rd_clk_en = cfg_rd_glc_clk_en;

endmodule
