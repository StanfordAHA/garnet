//
//--------------------------------------------------------------------------------
//          THIS FILE WAS AUTOMATICALLY GENERATED BY THE GENESIS2 ENGINE        
//  FOR MORE INFORMATION: OFER SHACHAM (CHIP GENESIS INC / STANFORD VLSI GROUP)
//    !! THIS VERSION OF GENESIS2 IS NOT FOR ANY COMMERCIAL USE !!
//     FOR COMMERCIAL LICENSE CONTACT SHACHAM@ALUMNI.STANFORD.EDU
//--------------------------------------------------------------------------------
//
//  
//	-----------------------------------------------
//	|            Genesis Release Info             |
//	|  $Change: 11904 $ --- $Date: 2013/08/03 $   |
//	-----------------------------------------------
//	
//
//  Source file: /nobackup/steveri/github/CGRAGenerator/hardware/generator_z/pe_new/pe/rtl/test_pe.svp
//  Source template: test_pe
//
// --------------- Begin Pre-Generation Parameters Status Report ---------------
//
//	From 'generate' statement (priority=5):
// Parameter use_cntr 	= 0
// Parameter en_double 	= 0
// Parameter use_shift 	= 1
// Parameter is_msb 	= 0
// Parameter lut_inps 	= 3
// Parameter use_bool 	= 1
// Parameter reg_inputs 	= 1
// Parameter use_div 	= 0
// Parameter use_add 	= 1
// Parameter mult_mode 	= 1
// Parameter reg_out 	= 0
//
//		---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ----
//
//	From Command Line input (priority=4):
//
//		---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ----
//
//	From XML input (priority=3):
//
//		---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ----
//
//	From Config File input (priority=2):
//
// ---------------- End Pre-Generation Pramameters Status Report ----------------

// reg_inputs (_GENESIS2_INHERITANCE_PRIORITY_) = 1
//
// reg_out (_GENESIS2_INHERITANCE_PRIORITY_) = 0
//
// use_add (_GENESIS2_INHERITANCE_PRIORITY_) = 1
//
// use_cntr (_GENESIS2_INHERITANCE_PRIORITY_) = 0
//
// use_bool (_GENESIS2_INHERITANCE_PRIORITY_) = 1
//
// use_shift (_GENESIS2_INHERITANCE_PRIORITY_) = 1
//
// mult_mode (_GENESIS2_INHERITANCE_PRIORITY_) = 1
//
// use_div (_GENESIS2_INHERITANCE_PRIORITY_) = 0
//
// is_msb (_GENESIS2_INHERITANCE_PRIORITY_) = 0
//
// en_double (_GENESIS2_INHERITANCE_PRIORITY_) = 0
//
// en_opt (_GENESIS2_DECLARATION_PRIORITY_) = 1
//
// en_trick (_GENESIS2_DECLARATION_PRIORITY_) = 0
//
// use_abs (_GENESIS2_DECLARATION_PRIORITY_) = 1
//
// use_max_min (_GENESIS2_DECLARATION_PRIORITY_) = 1
//
// use_relu (_GENESIS2_DECLARATION_PRIORITY_) = 1
//
// get_carry (_GENESIS2_DECLARATION_PRIORITY_) = 1
//
// debug (_GENESIS2_DECLARATION_PRIORITY_) = 0
//
// use_flip (_GENESIS2_DECLARATION_PRIORITY_) = 0
//
// use_acc (_GENESIS2_DECLARATION_PRIORITY_) = 0
//
// en_ovfl (_GENESIS2_DECLARATION_PRIORITY_) = 1
//
// en_debug (_GENESIS2_DECLARATION_PRIORITY_) = 1
//
// lut_inps (_GENESIS2_INHERITANCE_PRIORITY_) = 3
//



/*
use_add   = 1
mult_mode = 1
lut_inps  = 3

use_abs     = 1
use_max_min = 1
use_relu    = 1

*/

module   test_pe_unq1  #(
  parameter DataWidth = 16
) (
  input                clk,
  input                rst_n,
  input                clk_en,

  input         [31:0] cfg_d,
  input         [7:0]  cfg_a,
  input                cfg_en,


  input  [DataWidth-1:0]        data0,//op_a_in,
  input  [DataWidth-1:0]        data1,//op_b_in,
  input                         bit0,//op_d_p_in,
  input                         bit1,//op_e_p_in,
  input                         bit2,//op_f_p_in,



  output logic [DataWidth-1:0]  res,
  output logic                   irq,
  output logic                   res_p
);

logic  [DataWidth-1:0]        op_a;
logic  [DataWidth-1:0]        op_b;
logic                         op_d_p;
logic                         op_e_p;
logic                         op_f_p;

logic [DataWidth-1:0] comp_res;
logic                 comp_res_p;

  logic [0:0]             carry_out;




logic [15:0] inp_code;
logic [15:0] op_code;

always_ff @(posedge clk or negedge rst_n) begin
  if(~rst_n) begin
    inp_code <= 'h0;
    op_code  <= 'h0;
  end else if(cfg_en && (&cfg_a)) begin // (&cfg_a) means cfg_a == 8'hFF
    inp_code <= cfg_d[31:16];
    op_code  <= cfg_d[15:0];
  end
end


logic [15:0] nc_inp_code;
assign nc_inp_code = inp_code;
logic [15:0] nc_op_code;
assign nc_op_code = op_code;

test_opt_reg #(.DataWidth(DataWidth)) test_opt_reg_a
(
  .clk        (clk),
  .clk_en     (clk_en),
  .rst_n      (rst_n),
  .load       (cfg_en && (cfg_a == 8'hF0)),
  .val        (cfg_d[DataWidth-1:0]),
  .mode       (inp_code[1:0]),
  .data_in    (data0),//op_a_in),
  .res        (op_a)
);




logic                 op_b_ld;
logic [DataWidth-1:0] op_b_val;




  assign op_b_ld  = cfg_en && (cfg_a == 8'hF1);
  assign op_b_val = cfg_d[DataWidth-1:0];


test_opt_reg #(.DataWidth(DataWidth)) test_opt_reg_b
(
  .clk        (clk),
  .clk_en     (clk_en),
  .rst_n      (rst_n),
  .load       (op_b_ld),
  .val        (op_b_val),
  .mode       (inp_code[3:2]),
  .data_in    (data1),//op_b_in),
  .res        (op_b)
);





test_opt_reg #(.DataWidth(1)) test_opt_reg_d
(
  .clk        (clk),
  .clk_en     (clk_en),
  .rst_n      (rst_n),
  .load       (cfg_en && (cfg_a == 8'hF3)),
  .val        (cfg_d[0]),
  .mode       (inp_code[9:8]),
  .data_in    (bit0),//op_d_p_in),
  .res        (op_d_p)
);


test_opt_reg #(.DataWidth(1)) test_opt_reg_e
(
  .clk        (clk),
  .clk_en     (clk_en),
  .rst_n      (rst_n),
  .load       (cfg_en && (cfg_a == 8'hF4)),
  .val        (cfg_d[0]),
  .mode       (inp_code[11:10]),
  .data_in    (bit1),//op_e_p_in),
  .res        (op_e_p)
);


test_opt_reg #(.DataWidth(1)) test_opt_reg_f
(
  .clk        (clk),
  .clk_en     (clk_en),
  .rst_n      (rst_n),
  .load       (cfg_en && (cfg_a == 8'hF5)),
  .val        (cfg_d[0]),
  .mode       (inp_code[13:12]),
  .data_in    (bit2),//op_f_p_in),
  .res        (op_f_p)
);




logic V;




test_pe_comp_unq1  test_pe_comp
(
  .op_code (op_code[7:0]),

  .op_a     (op_a),
  .op_b     (op_b),
  .op_d_p   (op_d_p),


  .carry_out   (carry_out  ),



  .res      (comp_res),
  .ovfl     (V),
  .res_p    (comp_res_p)
);



logic result_flag;
logic res_lut;

    logic Z;
    logic N;
    logic C;


    logic [3:0] flag_sel;

    assign flag_sel = op_code[15: 12];

    assign C = carry_out[0];
    assign Z = ~|comp_res;
    assign N = comp_res[DataWidth-1];

    localparam PE_FLAG_EQ = 4'h0;
    localparam PE_FLAG_NE = 4'h1;
    localparam PE_FLAG_CS = 4'h2;
    localparam PE_FLAG_CC = 4'h3;
    localparam PE_FLAG_MI = 4'h4;
    localparam PE_FLAG_PL = 4'h5;
    localparam PE_FLAG_VS = 4'h6;
    localparam PE_FLAG_VC = 4'h7;
    localparam PE_FLAG_HI = 4'h8;
    localparam PE_FLAG_LS = 4'h9;
    localparam PE_FLAG_GE = 4'hA;
    localparam PE_FLAG_LT = 4'hB;
    localparam PE_FLAG_GT = 4'hC;
    localparam PE_FLAG_LE = 4'hD;
    localparam PE_FLAG_LUT = 4'hE;
    localparam PE_FLAG_PE  = 4'hF;


    always_comb begin
        case (flag_sel)
            PE_FLAG_EQ  : res_p = Z;
            PE_FLAG_NE  : res_p = ~Z;
            PE_FLAG_CS  : res_p = C;
            PE_FLAG_CC  : res_p = ~C;
            PE_FLAG_MI  : res_p = N;
            PE_FLAG_PL  : res_p = ~N;
            PE_FLAG_VS  : res_p = V;
            PE_FLAG_VC  : res_p = ~V;
            PE_FLAG_HI  : res_p = C & ~Z;
            PE_FLAG_LS  : res_p = ~C | Z;
            PE_FLAG_GE  : res_p = (N == V);
            PE_FLAG_LT  : res_p = (N != V);
            PE_FLAG_GT  : res_p = ~Z & (N == V);
            PE_FLAG_LE  : res_p = Z | (N != V);
            PE_FLAG_LUT : res_p = res_lut;
            PE_FLAG_PE  : res_p = comp_res_p;
            default     : res_p = comp_res_p;
        endcase
    end


    //assign result_flag = |({Z,N, C, comp_res_p} & flag_mask);







test_lut #(.DataWidth(1)) test_lut
(
  .cfg_clk  (clk),
  .cfg_rst_n(rst_n),
  .cfg_d    (cfg_d),
  .cfg_a    (cfg_a),
  .cfg_en   (cfg_en),

  .op_a_in  (op_d_p),
  .op_b_in  (op_e_p),
  .op_c_in  (op_f_p),

  .res      (res_lut)
);


  assign res   = comp_res;

logic irq_data;
logic irq_bit;

test_debug_reg #(.DataWidth(DataWidth)) test_debug_data
(
  .cfg_clk   (clk),
  .cfg_rst_n (rst_n),
  .cfg_d     (cfg_d),
  .cfg_en    (cfg_en && (cfg_a == 8'hE0)),

  .data_in   (res),

  .debug_irq (irq_data)
);

test_debug_reg #(.DataWidth(1)) test_debug_bit
(
  .cfg_clk   (clk),
  .cfg_rst_n (rst_n),
  .cfg_d     (cfg_d),
  .cfg_en    (cfg_en && (cfg_a == 8'hE1)),

  .data_in   (res_p),

  .debug_irq (irq_bit)
);

logic [1:0] irq_en;
assign irq_en = op_code[11 :10 ];

assign irq = |({irq_data,irq_bit} & irq_en);



endmodule
