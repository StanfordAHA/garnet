//;use POSIX;
//;my $backtick = "`";
///////////////////////////////////////////////////////////////////
// CGRA memory generator
//////////////////////////////////////////////////////////////////
`$backtick`define xassert(condition, message) if(condition) begin $display(message); $finish(1); end

//; my $dwidth 	 = parameter(Name=>'dwidth', val=> 64, doc=>'bank interface width');
//; my $wwidth   = parameter(Name=>'wwidth', val=> 16, doc=>'word width');
//; my $ddepth   = parameter(Name=>'ddepth', val=> 128, doc=>'number of words in the memory');
//; my $numwords = int($dwidth/$wwidth);
//; 
//; my $bbanks   = parameter(Name=>'bbanks', val=> 2, doc=>'number of banks in memory');
//; my $bank_addr_width = int(ceil(log($bbanks)/log(2)));
//; my $awidth = int(ceil(log($ddepth)/log(2))) + int(ceil(log($numwords)/log(2)));
//; my $full_addr = $awidth + $bank_addr_width;

module `mname()`(

   clk,
   clk_en,
   reset,
   flush,
   wen,

 //  linebuffer_data_in,
 //  linebuffer_cen_mem,
 //  linebuffer_wen_mem,
 //  linebuffer_addr_mem,
 //  linebuffer_data_out,

   // configuration to control the internal state
  // config_en,
  // config_wr,
  // config_rd,
  // config_addr,
  // config_wr_data,
  // config_rd_data,

   depth,
   valid,
   num_words_mem,
   ren_to_fifo,
   stencil_width

);

input wire                 clk;
input wire                 clk_en;
input wire                 reset;
input wire                 flush;
input wire                 wen;

//output wire[`$wwidth-1`:0]  linebuffer_data_in [`$bbanks-1`:0];
//output wire[`$bbanks-1`:0] 	linebuffer_cen_mem;
//output wire[`$bbanks-1`:0] 	linebuffer_wen_mem;
//output wire[`$awidth-1`:0]  linebuffer_addr_mem [`$bbanks-1`:0];
//input wire [`$wwidth-1`:0]  linebuffer_data_out [`$bbanks-1`:0];

// Configuration
//input wire                 config_en;
//input wire                 config_wr;
//input wire                 config_rd;
//input wire[31:0]           config_addr;
//input wire[31:0]           config_wr_data;
//output reg[31:0]           config_rd_data;

input wire [31:0]          stencil_width;
input wire [12:0]          depth;
output wire                valid;
input wire [12:0]          num_words_mem;
output wire                ren_to_fifo;

reg [31:0] lb_config_rd_data;
// Is this the last line in the thing? Valid_out should be gated based on the stencil
reg [31:0] vg_ctr;
reg valid_gate;
reg valid_int;
reg [12:0] depth_int;

assign valid_gate = (stencil_width == 0) ? 1 : vg_ctr >= (stencil_width - 1); 
assign valid = valid_gate ? valid_int : 0;
assign ren_to_fifo = (depth_int > 0) ? (num_words_mem >= (depth_int-1)) : 0;
//assign config_rd_data = lb_config_rd_data;

always @(posedge clk, posedge reset) begin
    if(reset) begin
       vg_ctr <= 0; 
    end
    else begin
        if(valid_int) begin
            vg_ctr <= (vg_ctr + 1) % depth_int;
        end
    end
end 

always @(posedge clk, posedge reset) begin
    if (reset) begin
        depth_int <= 0;
        valid_int <= 0;
        lb_config_rd_data <= 0;
    end
    else begin
        depth_int <= depth;

        // write the configuration
        /*if (config_en) begin
            if (config_wr) begin
              case (config_addr[31:24])
                5: begin
                  stencil_width <= config_wr_data;
                end
              endcase
            end
            if (config_rd) begin
                case (config_addr[31:24]) 
                 5: begin
                  lb_config_rd_data <= stencil_width;
                end
                endcase
            end
        end*/

        if (((num_words_mem >= depth_int) | (((num_words_mem) >= (depth_int-1)))) & (depth_int > 0)) begin
            valid_int <= 1;
        end
        else begin
            valid_int <= 0;
        end
    end
end

endmodule
