//;use POSIX;
//;my $backtick = "`";
///////////////////////////////////////////////////////////////////
// CGRA memory generator
//////////////////////////////////////////////////////////////////
`$backtick`define xassert(condition, message) if(condition) begin $display(message); $finish(1); end

//; my $dwidth 	 = parameter(Name=>'dwidth', val=> 64, doc=>'bank interface width');
//; my $wwidth   = parameter(Name=>'wwidth', val=> 16, doc=>'word width');
//; my $ddepth   = parameter(Name=>'ddepth', val=> 128, doc=>'number of words in the memory');
//; my $bbanks   = parameter(Name=>'bbanks', val=> 2, doc=>'number of banks in memory');
//; my $numwords = int($dwidth/$wwidth); 
//; my $bank_addr_width = int(ceil(log($bbanks)/log(2)));
//; my $awidth = int(ceil(log($ddepth)/log(2))) + int(ceil(log($numwords)/log(2)));
//; my $full_addr = $awidth + $bank_addr_width;

module `mname()`(
   clk,
   clk_en,
   reset,
   flush,

   ren,
   wen,

   data_in,
   data_out,

   almost_empty,
   almost_full,
   empty,
   full,
   depth,
   fifo_to_mem_data,
   fifo_to_mem_cen,
   fifo_to_mem_wen,
   fifo_to_mem_addr,
   mem_to_fifo_data,
   num_words_mem,

   // Config
   config_en,
   config_wr,
   config_addr,
   config_wr_data,
   config_rd_data
);

input wire 	clk;
input 		clk_en;
input wire 	reset;
input wire	flush;
input wire	ren;
input wire	wen;
input wire  [`$wwidth-1`:0] data_in;	
output wire [`$wwidth-1`:0] data_out;	
output wire	almost_empty;
output wire	almost_full;
output wire	empty;
output wire	full;

output wire [`$wwidth-1`:0] fifo_to_mem_data [`$bbanks-1`:0];
output wire [`$bbanks-1`:0] fifo_to_mem_cen;
output wire [`$bbanks-1`:0] fifo_to_mem_wen;
output wire [`$awidth-1`:0] fifo_to_mem_addr [`$bbanks-1`:0];
input wire  [`$wwidth-1`:0] mem_to_fifo_data [`$bbanks-1`:0];

output reg [12:0] num_words_mem;
input wire [12:0] depth;
// Config
input wire config_en;
input wire config_wr;
input wire [31:0] config_addr;
input wire [31:0] config_wr_data;
output reg [31:0] config_rd_data;

// ==========================
// Clock Gating
// ==========================
wire clk_gated;
wire clk_en_int;
assign clk_en_int = clk_en || (config_en && config_wr);
assign clk_gated = clk & clk_en_int;


// ==========================
// Address generation
// ==========================
reg [`$full_addr-1`:0] read_addr;
reg [`$full_addr-1`:0] write_addr;

wire [`$awidth-1`:0] read_addr_mem;
wire [`$awidth-1`:0] write_addr_mem;

wire [`$bbanks-1`: 0] ren_mem;
wire [`$bbanks-1`: 0] wen_mem;
wire [`$bbanks-1`: 0] cen_mem;

reg [`$bbanks-1`:0] write_buffed;
reg [`$wwidth-1`:0] write_buff [`$bbanks-1`:0];
reg [`$awidth-1`:0] write_buff_addr [`$bbanks-1`:0];

reg [`$wwidth-1`:0] data_in [`$bbanks-1`:0];
wire [`$wwidth-1`:0] data_out_sel [`$bbanks-1`:0];

reg [`$awidth-1`:0] data_addr [`$bbanks-1`:0];

reg init_stage;
reg read_to_write;
reg passthru;
reg [`$wwidth-1`:0] passthru_reg;

wire [`$bbanks-1`:0] wen_mem_en;
reg [`$wwidth-1`:0] data_out_reg;
reg [`$bbanks-1`:0] ren_mem_reg;

assign read_addr_mem = read_addr[`$full_addr-1`:`$bank_addr_width`];
assign write_addr_mem = write_addr[`$full_addr-1`:`$bank_addr_width`];

assign almost_empty = (num_words_mem <= 1);
assign almost_full = (num_words_mem >= (depth - 1));

assign empty = (num_words_mem == 0);
assign full = (num_words_mem == depth);


wire [`$bbanks-1`:0] same_bank;

//; for(my $i = 0; $i < $bbanks; $i++) {
assign same_bank[`$i`] = ren_mem[`$i`] & wen_mem[`$i`];
//; }
//; for(my $i = 0; $i < $bbanks; $i++) {
assign cen_mem[`$i`] = ren_mem[`$i`] | wen_mem_en[`$i`];
//; }

// ================
// Status signals
// ================
//; for(my $idx = $bbanks-1; $idx > 0; $idx--) {
	assign ren_mem[`$idx`] = ren & ((read_addr[`$bank_addr_width-1`:0]) == `$idx`);
//; }   
	assign ren_mem[0] = ren & ((read_addr[`$bank_addr_width-1`:0] == 0) | init_stage);

//; for(my $i = $bbanks-1; $i > 0; $i--) {
	assign wen_mem[`$i`] = wen & ((write_addr[`$bank_addr_width-1`]) == `$i`);
//; }
	assign wen_mem[0] = wen & ((write_addr[`$bank_addr_width-1`:0] == 0) | init_stage);

//; for(my $i = 0; $i < $bbanks; $i++) {
	assign wen_mem_en[`$i`] = (wen_mem[`$i`] & ~(same_bank[`$i`])) | write_buffed[`$i`];
//; }

//; for(my $i = 0; $i < $bbanks; $i++) {
	assign fifo_to_mem_data[`$i`] = write_buffed[`$i`] ? write_buff[`$i`] : data_in;
//; }
//; for(my $i = 0; $i < $bbanks; $i++) {
	assign fifo_to_mem_cen[`$i`] = cen_mem[`$i`];
//; }
//; for(my $i = 0; $i < $bbanks; $i++) {
	assign fifo_to_mem_wen[`$i`] = wen_mem_en[`$i`];
//; }
//; for(my $i = 0; $i < $bbanks; $i++) {
	assign fifo_to_mem_addr[`$i`] = data_addr[`$i`];
//; }
//; for(my $i = 0; $i < $bbanks; $i++) {
	assign data_out_sel[`$i`] = mem_to_fifo_data[`$i`];
//; }


// =========================
// Combinational updates
// =========================
always @(*) begin

	/* verilator lint_off WIDTH */
	num_words_mem = read_to_write ? (13'b0) :
		(write_addr == read_addr) ? (2**`$full_addr`) 
		: (write_addr > read_addr) ?
		    (write_addr - read_addr)
		   : ((2**`$full_addr`) - (read_addr - write_addr));
	/* verilator lint_on WIDTH */
//; for(my $i = 0; $i < $bbanks; $i++) {
	data_addr[`$i`] = write_buffed[`$i`] ?
			  write_buff_addr[`$i`] :
			  (ren_mem[`$i`] ? read_addr_mem : write_addr_mem);	
//; }

	if (ren_mem_reg[0]) begin
		data_out = (passthru) ? passthru_reg : data_out_sel[0];
	end
//; for(my $i = 1; $i < $bbanks; $i++) {
	else if (ren_mem_reg[`$i`]) begin
		data_out = (passthru) ? passthru_reg : data_out_sel[`$i`];
	end
//; }
	else begin
		data_out = data_out_reg;
	end

end


// =======================
// State updates
// =======================
reg circular_en;
always @(posedge clk_gated or posedge reset) begin
	if(reset == 1'b1) begin
		read_addr <= 0;
		write_addr <= 0;
		init_stage <= 1;
		read_to_write <= 1;
		data_out_reg <= 0;
		circular_en <= 0;
    passthru <= 0;
    passthru_reg <= 0;
	//; for (my $i = 0; $i < $bbanks; $i++) {
		write_buffed[`$i`] <= 0;
		write_buff[`$i`] <= 0;
		write_buff_addr[`$i`] <= 0;
		ren_mem_reg[`$i`] <= 0;
	//; }	
	end
	else begin

		if (config_en && config_wr) begin
	            case (config_addr[1:0])
                	0: circular_en <= config_wr_data[0];
        	        1: read_addr <= config_wr_data[`$full_addr-1`:0];
	                2: write_addr <= config_wr_data[`$full_addr-1`:0];
                	3: read_to_write <= config_wr_data[0];
            	    endcase
        	end
		
		else begin

		if (flush == 1'b1) begin
			read_addr <= 0;
			write_addr <= 0;
			init_stage <= 1;
			read_to_write <= 1;
			data_out_reg <= 0;
			circular_en <= 0;
      passthru <= 0;
      passthru_reg <= 0;
		//; for (my $i = 0; $i < $bbanks; $i++) {
			write_buffed[`$i`] <= 0;
			write_buff[`$i`] <= 0;
			write_buff_addr[`$i`] <= 0;
			ren_mem_reg[`$i`] <= 0;
		//; }	
		end	
		else begin
		///
			if (same_bank[0] == 1'b1) begin
				write_buffed[0] <= 1'b1;
				write_buff[0] <= data_in;
				write_buff_addr[0] <= write_addr_mem;
			end
		//; for (my $i = 1; $i < $bbanks; $i++) {
			else if (same_bank[`$i`]) begin
				write_buffed[`$i`] <= 1;
				write_buff[`$i`] <= data_in;
				write_buff_addr[`$i`] <= write_addr_mem;			
			end
		//; }

		//; for(my $i = 0; $i < $bbanks; $i++) {
			if (write_buffed[`$i`]) begin
				write_buffed[`$i`] <= 0;
			end
		//; }
			
			// If READ AND NO WRITE
			if (ren & ~wen) begin
        passthru <= 0;

				if(circular_en & ~empty) begin

					if ((read_addr + 1) % (2 ** `$full_addr`) == write_addr) begin
						// circular buffer
						read_addr <= 0;
						// caught up to write
						read_to_write <= 1;
					end
					else begin
						read_addr <= (read_addr + 1) % (2 ** `$full_addr`);
						read_to_write <= 0;
					end
        // circular_en  
				end

				else begin

					if (~empty) begin				

						read_addr <= (read_addr + 1) % (2 ** `$full_addr`);

						if ((read_addr + 1) % (2 ** `$full_addr`) == write_addr) begin
							read_to_write <= 1;
						end
						else begin
							read_to_write <= 0;
						end			

					end

        // else begin
				end

      end
			// If WRITE AND NO READ
			else if (wen & ~ren) begin
        passthru <= 0;
				write_addr <= (write_addr + 1) % (2 ** `$full_addr`);
				read_to_write <= 0;
			end	
			// If READ AND WRITE
			else if (ren & wen) begin
        if(empty & (|same_bank)) begin
          passthru <= 1;
          passthru_reg <= data_in;
        end
        else begin
          passthru <= 0;
        end
				read_addr <= (read_addr + 1) % (2 ** `$full_addr`);
				write_addr <= (write_addr + 1) % (2 ** `$full_addr`);
			end
      // No read or write - turn off passthru
      else begin
        passthru <= 0;
      end
			// Transition out of the init stage after a read or write
			if (ren | wen) begin
				init_stage <= 0;
			end

		//; for (my $i = 0; $i < $bbanks; $i++) {
			ren_mem_reg[`$i`] <= ren_mem[`$i`];
		//; }
			data_out_reg <= data_out;
		///
		end

		end

	end
end

	/* verilator lint_off WIDTH */
always @ (*) begin
    case (config_addr[2:0])
        0: config_rd_data = {31'b0, circular_en};
        1: config_rd_data = {`32-$awidth`'b0,read_addr};
        2: config_rd_data = {`32-($full_addr+1)`'b0,write_addr};
        3: config_rd_data = {31'b0, read_to_write};
	4: config_rd_data = {19'b0,num_words_mem};
        default: config_rd_data = 32'b0;
    endcase
end
	/* verilator lint_on WIDTH */
endmodule
