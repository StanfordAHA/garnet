//
//--------------------------------------------------------------------------------
//          THIS FILE WAS AUTOMATICALLY GENERATED BY THE GENESIS2 ENGINE        
//  FOR MORE INFORMATION: OFER SHACHAM (CHIP GENESIS INC / STANFORD VLSI GROUP)
//    !! THIS VERSION OF GENESIS2 IS NOT FOR ANY COMMERCIAL USE !!
//     FOR COMMERCIAL LICENSE CONTACT SHACHAM@ALUMNI.STANFORD.EDU
//--------------------------------------------------------------------------------
//
//  
//	-----------------------------------------------
//	|            Genesis Release Info             |
//	|  $Change: 11904 $ --- $Date: 2013/08/03 $   |
//	-----------------------------------------------
//	
//
//  Source file: /sim/ajcars/aha-arm-soc-june-2019/components/cgra/garnet/global_controller/genesis/axi_ctrl.svp
//  Source template: axi_ctrl
//
// --------------- Begin Pre-Generation Parameters Status Report ---------------
//
//	From 'generate' statement (priority=5):
// Parameter axi_addr_width 	= 12
// Parameter cfg_addr_width 	= 32
// Parameter cfg_bus_width 	= 32
//
//		---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ----
//
//	From Command Line input (priority=4):
//
//		---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ----
//
//	From XML input (priority=3):
//
//		---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ----
//
//	From Config File input (priority=2):
//
// ---------------- End Pre-Generation Pramameters Status Report ----------------

/*=============================================================================
** Module: axi_controller.svp
** Description:
**              AXI4-Lite controller
** Author: Taeyoung Kong
** Change history: 05/02/2019 - Initial implementation
**===========================================================================*/

// cfg_bus_width (_GENESIS2_INHERITANCE_PRIORITY_) = 32
//
// cfg_addr_width (_GENESIS2_INHERITANCE_PRIORITY_) = 32
//
// axi_addr_width (_GENESIS2_INHERITANCE_PRIORITY_) = 12
//

module axi_ctrl_unq1 (

    // axi4 lite slave signals
    input  logic                            clk,
    input  logic                            reset,
    input  logic [11:0]    AWADDR,
    input  logic                            AWVALID,
    output logic                            AWREADY,
    input  logic [31:0]     WDATA,
    input  logic                            WVALID,
    output logic                            WREADY,

    input  logic [11:0]    ARADDR,
    input  logic                            ARVALID,
    output logic                            ARREADY,
    output logic [31:0]     RDATA,
    output logic [1:0]                      RRESP,
    output logic                            RVALID,
    input  logic                            RREADY,

    // interface with global controller
    input  logic                            gc_to_axi_ready,

    output logic [11:0]    axi_to_gc_wr_addr,
    output logic [31:0]     axi_to_gc_wr_data,
    output logic                            axi_to_gc_wr_en,

    output logic                            axi_to_gc_rd_en,
    output logic [11:0]    axi_to_gc_rd_addr,
    input  logic [31:0]     gc_to_axi_rd_data
);

//============================================================================//
// AXI4-Lite fsm parameters and signals
//============================================================================//
localparam
    WRIDLE  = 2'd0,
    WRDATA  = 2'd1,
    WRDELAY = 2'd2,
    WRWAIT  = 2'd3;

logic [1:0]                     wstate;
logic                           wen;
logic [31:0]    wdata;
logic [11:0]   waddr;

localparam
    RDIDLE  = 2'd0,
    RDDELAY = 2'd1,
    RDWAIT  = 2'd2,
    RDDATA  = 2'd3;

logic [1:0]                     rstate;
logic                           ren;
logic [31:0]    rdata;
logic [11:0]   raddr;
logic                           rvalid;

//============================================================================//
// AXI4-Lite write fsm
//============================================================================//
assign AWREADY = (~reset) & (gc_to_axi_ready) & (wstate == WRIDLE) & (rstate == RDIDLE);
assign WREADY  = (wstate == WRDATA);

always_ff @(posedge clk or posedge reset) begin
    if (reset) begin
        wstate <= WRIDLE;
        wen <= 0;
        wdata <= 0;
        waddr <= 0;
    end
    else begin
        case (wstate) 
            WRIDLE: begin
                if (AWVALID & AWREADY) begin
                    wstate <= WRDATA;
                    waddr <= AWADDR;
                end
            end
            WRDATA: begin
                if (WVALID & WREADY) begin
                    wstate <= WRDELAY;
                    wdata <= WDATA; 
                    wen <= 1;
                end
            end
            WRDELAY: begin
                wen <= 0;
                wstate <= WRWAIT;
            end
            WRWAIT: begin
                if (gc_to_axi_ready) begin
                    wstate <= WRIDLE;
                end
            end
        endcase
    end
end

//============================================================================//
// AXI4-Lite read fsm
//============================================================================//
// Global controller cannot handle when AWVALID and ARVALID are asserted at the same cycle
// Therefore, we deassert ARREADY when AWVALID is asserted
assign ARREADY  = (~reset) & (gc_to_axi_ready) & (rstate == RDIDLE) & (wstate == WRIDLE) & (!AWVALID);
assign RDATA    = rdata;
assign RRESP    = 2'b00;  // OKAY
assign RVALID   = rvalid;

always_ff @(posedge clk or posedge reset) begin
    if (reset) begin
        rstate <= RDIDLE;
        raddr <= 0;
        rdata <= 0;
        rvalid <= 0;
        ren <= 0;
    end
    else begin
        case (rstate)
            RDIDLE: begin
                if (ARREADY & ARVALID) begin
                    raddr <= ARADDR;
                    rstate <= RDDELAY;
                    ren <= 1;
                end
            end
            RDDELAY: begin
                ren <= 0;
                rstate <= RDWAIT;
            end
            RDWAIT: begin
                if (gc_to_axi_ready) begin
                    rvalid <= 1;
                    rdata <= gc_to_axi_rd_data;
                    rstate <= RDDATA; 
                end
            end
            RDDATA: begin
                if (RVALID & RREADY) begin
                    rvalid <= 0;
                    rstate <= RDIDLE;
                end
            end
        endcase
    end
end

//============================================================================//
// output assignment
//============================================================================//
assign axi_to_gc_wr_addr = waddr;
assign axi_to_gc_wr_data = wdata;
assign axi_to_gc_wr_en   = wen;
assign axi_to_gc_rd_addr = raddr;
assign axi_to_gc_rd_en   = ren;

endmodule
