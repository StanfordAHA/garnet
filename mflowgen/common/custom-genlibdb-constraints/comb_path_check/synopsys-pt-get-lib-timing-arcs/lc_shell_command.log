#@ # 
#@ # Running lc_shell Version M-2017.06-SP3 for linux64 -- Oct 12, 2017
#@ # Date:   Tue Mar 12 18:51:13 2024
#@ # Run by: ajcars@aha-gf
#@ 

source /cad/synopsys/lc/M-2017.06-SP3/admin/setup//.synopsys_lc.setup
#@ # -- Starting source /cad/synopsys/lc/M-2017.06-SP3/admin/setup//.synopsys_lc.setup

#@ #
#@ #
#@ #		".synopsys_lc.setup" Initialization File for
#@ #
#@ #		    Lc_Shell and Library_compiler
#@ #
#@ #	The variables in this file define the behavior of many parts
#@ #	of the Synopsys Synthesis Tools.  Upon installation, they should 
#@ #	be reviewed and modified to fit your site's needs.  Each engineer
#@ #	can have a .synopsys file in his/her home directory or current
#@ #	directory to override variable settings in this file.  
#@ #
#@ 
#@ # System variables
#@ # system default value for sh_continue_on_error is "false"
#@ set sh_continue_on_error         "true"
#@ # system default value for sh_source_uses_search_path is "false"
#@ set sh_source_uses_search_path   "true"
#@ 
#@ # Enable customer support banner on fatal
#@ if { $sh_arch == "linux"    || $sh_arch == "amd64"    || $sh_arch == "linux64" ||      $sh_arch == "sparcOS5" || $sh_arch == "sparc64"  ||      $sh_arch == "x86sol32" || $sh_arch == "x86sol64" ||      $sh_arch == "rs6000"   || $sh_arch == "aix64" } {
#@    setenv SYNOPSYS_TRACE ""
#@ }
#@ 
#@ #
#@ # Load the procedures which make up part of the user interface.
#@ #
#@ source $synopsys_root/auxx/syn/.lc_procs.tcl
#@ # -- Starting source /cad/synopsys/lc/M-2017.06-SP3/auxx/syn/.lc_procs.tcl

#@ ##############################################################################
#@ #
#@ #
#@ # FILE:         auxx/syn/.lc_procs.tcl
#@ #
#@ # ABSTRACT:     These procedures are part of the lc_shell
#@ #               user interface.
#@ #               They are loaded by .synopsys_lc.setup.
#@ #
#@ ##############################################################################
#@ #
#@ #
#@ 
#@ ##############################################################################
#@ #
#@ #
#@ #  PROCEDURE:  add_model
#@ #
#@ #  ABSTRACT:  dummy call
#@ #
#@ ##############################################################################
#@ #
#@ 
#@ proc add_model { args } {
#@   return [uplevel #0 $cmd]
#@ }
#@ 
#@ ##############################################################################
#@ #
#@ #  PROCEDURE:   remove_design
#@ #
#@ #  ABSTRACT:    map remove_design to remove_lib
#@ #
#@ #  HISTORY :    2014/05/09, Junhan Yi, initial
#@ #
#@ ##############################################################################
#@ 
#@ proc remove_design { args } {
#@   parse_proc_arguments -args $args ra
#@ 
#@   if {[info exists ra(-library)]} {
#@     set cmd [format {remove_lib %s} $ra(-library)]
#@   } elseif {[info exists ra(-all)]} {
#@     set cmd {remove_lib -all}
#@   } else {
#@     set cmd [format {remove_lib [list %s]} $args]
#@   }
#@ 
#@   return [uplevel #0 $cmd]
#@ }
#@ 
#@ define_proc_attributes remove_design -hide_body     -info " alias of remove_lib "     -define_args {      {file_names "" file_names list {optional hidden}}    }
#@ # -- End source /cad/synopsys/lc/M-2017.06-SP3/auxx/syn/.lc_procs.tcl

#@ source $synopsys_root/auxx/lc/.lc_scripts.tcl
#@ # -- Starting source /cad/synopsys/lc/M-2017.06-SP3/auxx/lc/.lc_scripts.tcl

#@ ##############################################################################
#@ #
#@ #
#@ # FILE:         lc_scripts.tcl
#@ #
#@ # ABSTRACT:     These procedures are part of the lc_shell
#@ #               user interface.
#@ #               They are loaded by .synopsys_lc.setup.
#@ #
#@ ##############################################################################
#@ 
#@ ##############################################################################
#@ # Proc: read in the csv file to list of list
#@ # Author: Junhan Yi
#@ # Date: 2015/11/01
#@ # -channel: the input csv file
#@ # -header: == 1: use first line as index; header == 0: use row number as index
#@ # -symbol: delimiter, default is ","
#@ ##############################################################################
#@ proc read_csv { channel { header 1 } { symbol , }} {
#@ 	set quote 0	
#@ 	set data [ split [ read $channel nonewline ] "\n" ]
#@ 	foreach line $data {
#@ 		set quote [ expr { $quote + [ regexp -all \" $line ]}]
#@ 		if { [ expr { $quote % 2 }] == "0" } {
#@ 			set quote 0
#@ 			append row_temp $line
#@ 			set row_temp [ split $row_temp , ]	
#@ 			foreach section $row_temp {
#@ 				set quote [ expr { $quote + [ regexp -all \" $section ]}]
#@ 				if { [ expr { $quote % 2 }] == "0" } {
#@ 					append cell_temp $section
#@ 					set cell_temp [ regsub {^\s*(.*\S)\s*$} $cell_temp {\1} ]
#@ 					set cell_temp [ regsub {^\s*$} $cell_temp {\1} ]
#@ 					set cell_temp [ regsub {"(.*)"} $cell_temp {\1} ]
#@ 					lappend cell $cell_temp
#@ 					unset cell_temp
#@ 					set quote 0
#@ 				} else {
#@ 					append cell_temp $section$symbol
#@ 				}
#@ 			}
#@ 			lappend final [ regsub -all {""} $cell \" ]
#@ 			unset cell
#@ 			unset row_temp
#@ 		} else {
#@ 			append row_temp $line\n
#@ 		}
#@ 	}
#@ 	# return list of list
#@ 	return $final
#@ }
#@ 
#@ # This proc is hidden
#@ define_proc_attributes read_csv -hidden
#@ 
#@ ##############################################################################
#@ # Proc: sort the db_filename
#@ # Author: Junhan Yi
#@ # Date: 2015/11/01
#@ # Return array: key is db name, value is a list of colomn number
#@ ##############################################################################
#@ proc sort_array_by_db_filename { final id } {
#@ 	set row [ llength $final ]
#@ 
#@ 	for { set i 1 } { $i < $row } { incr i } {
#@ 		set db_name [lindex [lindex $final $i] $id]
#@     set db_ids [array names db_map $db_name]
#@     if { [string length $db_ids] > 0} {
#@       set db_map($db_name) [concat $db_map($db_name) $i]
#@     } else {
#@       set db_map($db_name) $i
#@     }
#@   }
#@ 
#@   return [ array get db_map ]
#@ }
#@ 
#@ # This proc is hidden
#@ define_proc_attributes sort_array_by_db_filename -hidden
#@ 
#@ ##############################################################################
#@ # Proc: get nldm delay point index/value
#@ # Author: Junhan Yi
#@ # Date: 2015/11/01
#@ # Args: -matching_point: 1: fit; others: bucket;
#@ # Return: for fit mode, return 1 grid point
#@ #   for bucket mode, return a list of grid points
#@ #
#@ # Support NLDM NLPM query
#@ #
#@ # For different dimension lookup table
#@ #         fit                     bucket
#@ #   2-D:  1 (idx1,idx2,val)       4 * 3 (idx1,idx2,val)
#@ #   1-D:  1 (idx1,val)            2 * 2 (idx1,val)
#@ #   0-D:  1 (val)                 1 (val)
#@ #
#@ # The return array always contain 3 items (fit mode) or 12 items (bucket mode)
#@ # The unused ones are left empty for 1-D/0-D lookup table
#@ # If find any error, return array contains same number itmes with empty value
#@ ##############################################################################
#@ proc get_nldm_delay_point { line header idx {matching_point 1} } {
#@ 
#@   set column [llength $header]
#@ 	for { set j 0 } { $j < $column } { incr j } {
#@ 		set rec([ lindex $header $j ],$idx) [ lindex $line $j ]
#@   }
#@ 
#@   # initial return array
#@   if { $matching_point ==1 } {
#@     set tb(idx1,$idx) ""
#@     set tb(idx2,$idx) ""
#@     set tb(value,$idx) ""
#@   } else {
#@     set tb(idx1_a,$idx) ""
#@     set tb(idx2_a,$idx) ""
#@     set tb(value_a,$idx) ""
#@     set tb(idx1_b,$idx) ""
#@     set tb(idx2_b,$idx) ""
#@     set tb(value_b,$idx) ""
#@     set tb(idx1_c,$idx) ""
#@     set tb(idx2_c,$idx) ""
#@     set tb(value_c,$idx) ""
#@     set tb(idx1_d,$idx) ""
#@     set tb(idx2_d,$idx) ""
#@     set tb(value_d,$idx) ""
#@   }
#@ 
#@   # check library
#@   if { [string length [array names rec library,$idx]] ==0 ||
#@     [string length $rec(library,$idx)] ==0} {
#@     echo "line [expr $idx+1]: Error! Must specify field 'library' for query."
#@     return [ array get tb ]
#@   }
#@   # check cell 
#@   if { [string length [array names rec cell,$idx]] ==0 ||
#@     [string length $rec(cell,$idx)] ==0} {
#@     echo "line [expr $idx+1]: Error! Must specify field 'cell' for query."
#@     return [ array get tb ]
#@   }
#@ 
#@   # get the cell, save the collection into global array for fast access next time.
#@   global lc_cells
#@   set lib_cell_name [array names lc_cells $rec(library,$idx)/$rec(cell,$idx)]
#@   if { [string length $lib_cell_name] > 0} {
#@     set pcell $lc_cells($lib_cell_name)
#@   } else {
#@     set pcell [get_lib_cells $rec(library,$idx)/$rec(cell,$idx)]
#@     if { [sizeof_collection $pcell] == 1 } {
#@       set lc_cells($rec(library,$idx)/$rec(cell,$idx)) $pcell
#@     } else {
#@       echo "line [expr $idx+1]: Error! Can't find this cell group."
#@       return [array get tb ]
#@     }
#@   }
#@ 
#@   # check group
#@   if { [string length [array names rec group,$idx]] ==0 ||
#@     [string length $rec(group,$idx)] ==0} {
#@     echo "line [expr $idx+1]: Error! Must specify field 'group' for query."
#@     return [ array get tb ]
#@   }
#@ 
#@   # get value NOT from lookup table
#@   if { [string equal $rec(group,$idx) leakage_power] } {
#@     # leakage power
#@  
#@     # set filter
#@     if { [string length [array names rec when_cond,$idx]] >0 &&
#@       [string length $rec(when_cond,$idx)] >0 } {
#@       set ft \(when==\"$rec(when_cond,$idx)\"\)
#@     }
#@     if { [string length [array names rec related_pg_pin,$idx]] >0 &&
#@       [string length $rec(related_pg_pin,$idx)] >0 } {
#@       if {[info exists ft]} {
#@         set ft $ft&&\(related_pg_pin==$rec(related_pg_pin,$idx)\)
#@       } else {
#@         set ft \(related_pg_pin==$rec(related_pg_pin,$idx)\)
#@       } 
#@     }
#@ 
#@     # set options: of_object, class_type, filter
#@     lappend opts -of_objects $pcell -class_type leakage_power
#@     if {[info exists ft]} {
#@       lappend opts -filter $ft
#@     }
#@ 
#@     # get leakage power 
#@     set arc [eval get_lib_objects $opts]
#@     
#@     if {[sizeof_collection $arc] == 0} {
#@       echo "line [expr $idx+1]: Error! Can't find this timing/power group."
#@       return [array get tb ]
#@     } elseif {[sizeof_collection $arc] > 1} {
#@     # using the first one !!!
#@       echo "line [expr $idx+1]: Warning! Find multiple timing/power groups, use the first one!"
#@       set arc [index_collection $arc 0]
#@     }
#@ 
#@     set value [format %g [get_lib_attribute $arc value]]
#@ 
#@     if { $matching_point ==1 } {
#@       if {[info exists value]} {
#@         set tb(value,$idx) $value
#@       }
#@     } else {
#@       if {[info exists value]} {
#@         set tb(value_a,$idx) $value
#@       }
#@     }
#@ 
#@     return [ array get tb ]
#@   }
#@ 
#@   # get value from lookup table
#@   if { [string equal $rec(group,$idx) cell_rise] ||
#@     [string equal $rec(group,$idx) cell_fall] ||
#@     [string equal $rec(group,$idx) rise_constraint] ||
#@     [string equal $rec(group,$idx) fall_constraint] ||
#@     [string equal $rec(group,$idx) rise_propagation] ||
#@     [string equal $rec(group,$idx) fall_propagation] ||
#@     [string equal $rec(group,$idx) rise_transition] ||
#@     [string equal $rec(group,$idx) fall_transition] ||
#@     [string equal $rec(group,$idx) ocv_sigma_cell_rise] ||
#@     [string equal $rec(group,$idx) ocv_sigma_cell_fall] ||
#@     [string equal $rec(group,$idx) ocv_sigma_rise_constraint] ||
#@     [string equal $rec(group,$idx) ocv_sigma_fall_constraint] ||
#@     [string equal $rec(group,$idx) ocv_sigma_rise_transition] ||
#@     [string equal $rec(group,$idx) ocv_sigma_fall_transition] } {
#@     # NLDM timing
#@ 
#@     # set filter
#@     if { [string length [array names rec timing_type,$idx]] >0 &&
#@       [string length $rec(timing_type,$idx)] >0 } {
#@       set ft \(timing_type==$rec(timing_type,$idx)\)
#@     }
#@     if { [string length [array names rec timing_sense,$idx]] >0 &&
#@       [string length $rec(timing_sense,$idx)] >0 } {
#@       if {[info exists ft]} {
#@         set ft $ft&&\(timing_sense==$rec(timing_sense,$idx)\)
#@       } else {
#@         set ft \(timing_sense==$rec(timing_sense,$idx)\)
#@       } 
#@     }
#@     if { [string length [array names rec when_cond,$idx]] >0 &&
#@       [string length $rec(when_cond,$idx)] >0 } {
#@       if {[info exists ft]} {
#@         set ft $ft&&\(when==\"$rec(when_cond,$idx)\"\)
#@       } else {
#@         set ft \(when==\"$rec(when_cond,$idx)\"\)
#@       }
#@     }
#@ 
#@     # set options: of_object, from pin, to pin, filter
#@     lappend opts -of_objects $pcell
#@     if { [string length [array names rec pin,$idx]] >0 &&
#@       [string length $rec(pin,$idx)] >0 } {
#@       lappend opts -to $rec(pin,$idx)
#@     }
#@     if { [string length [array names rec related_pin,$idx]] >0 &&
#@       [string length $rec(related_pin,$idx)] >0 } {
#@       lappend opts -from $rec(related_pin,$idx)
#@     }
#@     if {[info exists ft]} {
#@       lappend opts -filter $ft
#@     }
#@   
#@     # get timing arc
#@     set arc [eval get_lib_timing_arcs $opts]
#@ 
#@   } elseif { [string equal $rec(group,$idx) rise_power] ||
#@     [string equal $rec(group,$idx) fall_power] } {
#@     # NLPM internal power
#@ 
#@     # set filter
#@     if { [string length [array names rec when_cond,$idx]] >0 &&
#@       [string length $rec(when_cond,$idx)] >0 } {
#@       set ft \(when==\"$rec(when_cond,$idx)\"\)
#@     }
#@     if { [string length [array names rec related_pg_pin,$idx]] >0 &&
#@       [string length $rec(related_pg_pin,$idx)] >0 } {
#@       if {[info exists ft]} {
#@         set ft $ft&&\(related_pg_pin==$rec(related_pg_pin,$idx)\)
#@       } else {
#@         set ft \(related_pg_pin==$rec(related_pg_pin,$idx)\)
#@       } 
#@     }
#@     if { [string length [array names rec related_pin,$idx]] >0 &&
#@       [string length $rec(related_pin,$idx)] >0 } {
#@       if {[info exists ft]} {
#@         set ft $ft&&\(related_pin==$rec(related_pin,$idx)\)
#@       } else {
#@         set ft \(related_pin==$rec(related_pin,$idx)\)
#@       } 
#@     }
#@ 
#@     # get pin
#@     if { [string length [array names rec pin,$idx]] >0 &&
#@       [string length $rec(pin,$idx)] >0 } {
#@       set pin [get_lib_objects -of_objects $pcell -class_type pin -filter name==$rec(pin,$idx)]
#@       if {[sizeof_collection $pin] != 1} {
#@         echo "line [expr $idx+1]: Error! Can't find this pin group."
#@         return [array get tb ]
#@       }
#@ 
#@       # set options: of_object, -class_type, filter
#@       lappend opts -of_objects $pin -class_type internal_power
#@       if {[info exists ft]} {
#@         lappend opts -filter $ft
#@       }
#@       
#@       # get internal power 
#@       set arc [eval get_lib_objects $opts]
#@     }
#@   }
#@ 
#@   if {[sizeof_collection $arc] == 0} {
#@     echo "line [expr $idx+1]: Error! Can't find this timing/power group."
#@     return [array get tb ]
#@   } elseif {[sizeof_collection $arc] > 1} {
#@     # using the first one !!!
#@     echo "line [expr $idx+1]: Warning! Find multiple timing/power groups, use the first one!"
#@     set arc [index_collection $arc 0]
#@   }
#@ 
#@   # get the lookup table
#@   set lt [get_lookup_table -of_object $arc $rec(group,$idx)]
#@ 
#@   if {[sizeof_collection $lt] == 0} {
#@     echo "line [expr $idx+1]: Error! Can't find this lookup table."
#@     return [array get tb ]
#@   } elseif {[sizeof_collection $lt] > 1} {
#@     # using the first one !!!
#@     echo "line [expr $idx+1]: Warning! Find multiple lookup table, use the first one!"
#@     set lt [index_collection $lt 0]
#@   }
#@ 
#@   # won't consider index pairing for now
#@   # input_slew == input_net_transition/input_transition_time
#@   # output_load == total_output_net_capacitance
#@   set index1 input_net_transition
#@   set index2 total_output_net_capacitance
#@ 
#@   set ids [lookup_table variables $lt]
#@   
#@   if { [llength $ids] == 1} {
#@     set index1 [lindex $ids 0]
#@   } elseif { [llength $ids] == 2} {
#@     set index1 [lindex $ids 0]
#@     set index2 [lindex $ids 1]
#@   }
#@     
#@   # constraint template could have issue here
#@   # constraint variable related_pin_transition/constrained_pin_transition
#@   # doesn't follow the input csv table index name input_slew/output_load
#@   # then we don't know how to pair them
#@   if { $index1=="total_output_net_capacitance" } {
#@     set tmp_index $index1
#@     set index1 $index2
#@     set index2 $tmp_index
#@   }
#@ 
#@   if { [string length [array names rec input_slew,$idx]] >0 &&
#@     [string length $rec(input_slew,$idx)] >0 } {
#@     lappend pointl $index1 $rec(input_slew,$idx)
#@   }
#@   if { [string length [array names rec output_load,$idx]] >0 &&
#@     [string length $rec(output_load,$idx)] >0 } {
#@     lappend pointl $index2 $rec(output_load,$idx)
#@   }
#@ 
#@   # lookup_table fit/bucket â€¦
#@   if { $matching_point ==1 } {
#@     if {[info exists pointl]} {
#@       redirect -variable msg {echo [set m_list [lookup_table fit $lt -index $pointl]]}
#@     } else {
#@       redirect -variable msg {echo [set m_list [lookup_table fit $lt]]}
#@     }
#@     if {[info exists m_list]} {
#@       if {[llength $m_list] == 3} {
#@         set tb(idx1,$idx) [format %g [lindex $m_list 0] ]
#@         set tb(idx2,$idx) [format %g [lindex $m_list 1] ]
#@         set tb(value,$idx) [format %g [lindex $m_list 2] ]
#@       } elseif {[llength $m_list] == 2} {
#@         set tb(idx1,$idx) [format %g [lindex $m_list 0] ]
#@         set tb(value,$idx) [format %g [lindex $m_list 1] ]
#@       } elseif {[llength $m_list] == 1} {
#@         set tb(value,$idx) [format %g [lindex $m_list 0] ]
#@       }
#@     }
#@   } else {
#@     if {[info exists pointl]} {
#@       redirect -variable msg {echo [set m_list [lookup_table bucket $lt -index $pointl]]}
#@     } else {
#@       redirect -variable msg {echo [set m_list [lookup_table bucket $lt]]}
#@     }
#@     if {[info exists m_list]} {
#@       if {[llength $m_list] == 4} {
#@         set tb(idx1_a,$idx) [format %g [lindex [lindex $m_list 0] 0] ]
#@         set tb(idx2_a,$idx) [format %g [lindex [lindex $m_list 0] 1] ]
#@         set tb(value_a,$idx)  [format %g [lindex [lindex $m_list 0] 2] ]
#@         set tb(idx1_b,$idx) [format %g [lindex [lindex $m_list 1] 0] ]
#@         set tb(idx2_b,$idx) [format %g [lindex [lindex $m_list 1] 1] ]
#@         set tb(value_b,$idx)  [format %g [lindex [lindex $m_list 1] 2] ]
#@         set tb(idx1_c,$idx) [format %g [lindex [lindex $m_list 2] 0] ]
#@         set tb(idx2_c,$idx) [format %g [lindex [lindex $m_list 2] 1] ]
#@         set tb(value_c,$idx)  [format %g [lindex [lindex $m_list 2] 2] ]
#@         set tb(idx1_d,$idx) [format %g [lindex [lindex $m_list 3] 0] ]
#@         set tb(idx2_d,$idx) [format %g [lindex [lindex $m_list 3] 1] ]
#@         set tb(value_d,$idx)  [format %g [lindex [lindex $m_list 3] 2] ]
#@       } elseif {[llength $m_list] == 2} {
#@         set tb(idx1_a,$idx) [format %g [lindex [lindex $m_list 0] 0] ]
#@         set tb(value_a,$idx)  [format %g [lindex [lindex $m_list 0] 1] ]
#@         set tb(idx1_b,$idx) [format %g [lindex [lindex $m_list 1] 0] ]
#@         set tb(value_b,$idx)  [format %g [lindex [lindex $m_list 1] 1] ]
#@       } elseif {[llength $m_list] == 1} {
#@         set tb(value_a,$idx) [format %g [lindex $m_list 0] ]
#@       }
#@     }
#@   }
#@   if {[string match {[a-zA-Z]*} $msg]} {
#@     echo Line [expr $idx+1]: Error! [string trim $msg \n]
#@   }
#@ 
#@   return [ array get tb ]
#@ }
#@ 
#@ # This proc is hidden
#@ define_proc_attributes get_nldm_delay_point -hidden
#@ 
#@ ##############################################################################
#@ # Proc: get_lib_grid_points
#@ # Author: Junhan Yi
#@ # Date: 2015/11/01
#@ # -matching_point: 1 fit; 2 bucket
#@ # -input_csv_file: the input csv file contains the querry condition
#@ # -output_csv_file: the input csv file contains the querry condition and query result
#@ #
#@ # Modified: Junhan Yi 2015/12/10
#@ #   change proc name from "check_qualified_data_point" to "get_lib_lookup_data"
#@ # Modified: Junhan Yi 2016/01/05
#@ #   change proc name from "get_lib_lookup_data" to "get_lib_grid_points"
#@ ##############################################################################
#@ proc get_lib_grid_points {args} {
#@ 
#@   # get the args
#@   parse_proc_arguments -args $args ra
#@   set input_csv_file $ra(input_csv_file)
#@   set output_csv_file $ra(output_csv_file)
#@ 
#@   if { [string length [array names ra matching_point]] ==0 } {
#@     set matching_point 1
#@   } else {
#@     set matching_point $ra(matching_point)
#@   }
#@ 
#@   # get the input csv data, put in 2-D table (list of list)
#@   set in [open $input_csv_file r]
#@   set table [ read_csv $in ]
#@   close $in
#@ 	
#@   # get row/column/header
#@   set row [ llength $table ]
#@   set header [ lindex $table 0 ]
#@   set column [ llength $header ]
#@ 
#@   # check each header index name is correct
#@   set all_header {db_filename instance library cell pin group related_pin timing_type timing_sense when_cond related_pg_pin input_slew output_load}
#@   foreach item $header {
#@     if {[lsearch -exact $all_header $item] <0 } {
#@       echo "Error: Can't use '$item' as index."
#@       echo "The allowed index names are 'db_filename instance library cell pin group related_pin timing_type timing_sense when_cond related_pg_pin input_slew output_load'."
#@       return;
#@     }
#@   }
#@   
#@   # db_id is the colomn for "db_filename"
#@   set db_id [lsearch -exact $header db_filename]
#@   if { $db_id <0 } {
#@     echo "Error: User must specify 'db_filename' index in the input_csv_file."
#@     return
#@   }
#@   set lib_id [lsearch -exact $header library]
#@   if { $lib_id <0 } {
#@     echo "Error: User must specify 'library' index in the input_csv_file."
#@     return
#@   }
#@   
#@   # db_map is the mapping from db_filename to "row number" list
#@   array set db_map [sort_array_by_db_filename $table $db_id]
#@   set db_names [array names db_map]
#@   global lc_cells
#@   
#@   # set process meter
#@   incr row -1
#@   set count 1
#@   if { $row > 10000 } {
#@     set pct_instance [expr $row/100]
#@   } else {
#@     set pct_instance 100
#@   }
#@   
#@   # check each db at a time for saving memory
#@   foreach db $db_names {
#@     redirect -variable msg {echo [read_db $db]}
#@     set idx_list $db_map($db)
#@     array set lc_cells {0 0}
#@     foreach idx $idx_list {
#@ 
#@       # echo process meter
#@       if { $count % $pct_instance == 0 } {
#@         echo "Processing Cell Instance $count : out of $row"
#@         #echo [eval date]
#@       }
#@ 
#@       # get the querry data
#@       set line [lindex $table $idx]
#@       array set result [get_nldm_delay_point $line $header $idx $matching_point]
#@       
#@       # save the querry result
#@       if { $matching_point ==1 } {
#@         lappend line $result(idx1,$idx)
#@         lappend line $result(idx2,$idx)
#@         lappend line $result(value,$idx)
#@       } else {
#@         lappend line $result(idx1_a,$idx)
#@         lappend line $result(idx2_a,$idx)
#@         lappend line $result(value_a,$idx)
#@         lappend line $result(idx1_b,$idx)
#@         lappend line $result(idx2_b,$idx)
#@         lappend line $result(value_b,$idx)
#@         lappend line $result(idx1_c,$idx)
#@         lappend line $result(idx2_c,$idx)
#@         lappend line $result(value_c,$idx)
#@         lappend line $result(idx1_d,$idx)
#@         lappend line $result(idx2_d,$idx)
#@         lappend line $result(value_d,$idx)
#@       }
#@       set table [lreplace $table $idx $idx $line]
#@       
#@       incr count
#@     }
#@     unset lc_cells
#@ 		set lib_name [lindex [lindex $table $idx] $lib_id]
#@     redirect -variable msg {echo [remove_lib $db:$lib_name]}
#@ 
#@   }
#@ 
#@   # write to output csv file
#@   set out [open $output_csv_file w+]
#@ 
#@   if { $matching_point ==1 } {
#@     lappend header idx1 idx2 value
#@   } else {
#@     lappend header idx1_a idx2_a value_a idx1_b idx2_b value_b idx1_c idx2_c value_c idx1_d idx2_d value_d
#@   }
#@   set table [lreplace $table 0 0 $header]
#@   set row [ llength $table ]
#@   set column [ llength $header ]
#@ 
#@   set symbol ,
#@   for { set i 0 } { $i < $row } { incr i } {		
#@     puts -nonewline $out [lindex [lindex $table $i] 0]
#@ 	  for { set j 1 } { $j < $column } { incr j } {
#@       puts -nonewline $out $symbol
#@       puts -nonewline $out [lindex [lindex $table $i] $j]
#@ 		}
#@     puts $out ""
#@ 	}
#@   close $out
#@ 
#@ }
#@ 
#@ define_proc_attributes get_lib_grid_points     -info " Get the qualified grid points based on query parameter"     -define_args {
#@       {input_csv_file "The input file name contains query parameter" input_csv_file string required}
#@       {output_csv_file "The output file name for query result" output_csv_file string required}
#@       {matching_point "Query method: '1' for 1-closest grid point (default), '4' for 4 bucket grid points" matching_point one_of_string {optional value_help {values {1 4}}}}
#@ }
#@ 
#@ ##############################################################################
#@ # proc: write_records_in_csv
#@ # Output the data extracted from SQL database to $out_file csv file
#@ # file_id: fild id from csv filenam $out_file
#@ # arr: collection from SQL query commands
#@ # num_col: number of columns in $out_file
#@ ##############################################################################
#@ proc write_records_in_csv {file_id arr num_col} {
#@   global out_file
#@   set sz [expr [llength $arr]/$num_col]
#@   for {set i 0} {$i < $sz} {incr i} {
#@     set val ""
#@     for {set j 0} {$j < $num_col} {incr j} {
#@ 	set val1 [lindex $arr [expr $i*$num_col+$j]]   
#@ 	if {$j == 0} {
#@ 	    set val $val1
#@ 	} else {  
#@ 	    set val [concat $val,$val1]  
#@ 	} 
#@ 	#puts stdout j=$j
#@     }
#@     puts $file_id $val
#@     #puts stdout i=$i
#@   }
#@   #puts stdout "$sz records written to $out_file"
#@ }
#@ 
#@ define_proc_attributes write_records_in_csv -hidden
#@ 
#@ # -- End source /cad/synopsys/lc/M-2017.06-SP3/auxx/lc/.lc_scripts.tcl

#@ source $synopsys_root/auxx/lc/analyze_trend.tcl
#@ # -- Starting source /cad/synopsys/lc/M-2017.06-SP3/auxx/lc/analyze_trend.tcl

#@ ##############################################################################
#@ # Proc: analyze_trend   Author: Junhan Yi   Date: 2015/12/09
#@ #   analyze the input float array monotonicity trend
#@ #   return a char like "-, /, \, V, ^, N, u, M, W, X"
#@ # float_list: input float list, must be at least 2 members
#@ # -relative_tolerance: relative tolerance, default is 0.01
#@ # -absolute_tolerance: absolute tolerance, default is 0.000001
#@ ##############################################################################
#@ proc analyze_trend { args } {
#@ 
#@   # get the args
#@   parse_proc_arguments -args $args ra
#@   set float_list $ra(float_list)
#@ 
#@   if { [string length [array names ra -relative_tolerance]] ==0 } {
#@     set rel_tol 0.01
#@   } else {
#@     set rel_tol $ra(-relative_tolerance)
#@   }
#@   if { [string length [array names ra -absolute_tolerance]] ==0 } {
#@     set abs_tol 0.000001
#@   } else {
#@     set abs_tol $ra(-absolute_tolerance)
#@   }
#@   
#@   set count [llength $float_list]
#@   if {$count <= 1} {
#@     echo "Can't analysis: list must have at least 2 members."
#@   }
#@ 
#@   set trend 0
#@   
#@   for { set i 0 } { $i < $count - 1 } { incr i } {
#@     set fa [lindex $float_list $i]
#@     set fb [lindex $float_list $i+1]
#@ 
#@     set gap [expr abs($fa-$fb)]
#@     set rel_gap [expr ($fa+$fb)*0.5*$rel_tol]
#@     
#@     if {$gap <= $abs_tol || $gap <= $rel_gap} {
#@       switch -exact -- $trend {
#@         "0" { set trend "-" }
#@         "-" { set trend "-" }
#@         "\\" { set trend "\\" }
#@         "/" { set trend "/" }
#@         "V" { set trend "V" }
#@         "^" { set trend "^" }
#@         "N" { set trend "N" }
#@         "u" { set trend "u" }
#@         "M" { set trend "M" }
#@         "W" { set trend "W" }
#@         default { set trend "X" }
#@       }
#@     } elseif {$fa > $fb} {
#@       switch -exact -- $trend {
#@         "0" { set trend "\\" }
#@         "-" { set trend "\\" }
#@         "\\" { set trend "\\" }
#@         "/" { set trend "^" }
#@         "V" { set trend "u" }
#@         "^" { set trend "^" }
#@         "u" { set trend "u" }
#@         "N" { set trend "M" }
#@         "M" { set trend "M" }
#@         "W" { set trend "X" }
#@         default { set trend "X" }
#@       }
#@     } elseif {$fa < $fb} {
#@       switch -exact -- $trend {
#@         "0" { set trend "/" }
#@         "-" { set trend "/" }
#@         "\\" { set trend "V" }
#@         "/" { set trend "/" }
#@         "V" { set trend "V" }
#@         "^" { set trend "N" }
#@         "N" { set trend "N" }
#@         "u" { set trend "W" }
#@         "M" { set trend "X" }
#@         "W" { set trend "W" }
#@         default { set trend "X" }
#@       }
#@     }
#@     if {$trend == "X"} {break}
#@   }
#@ 
#@   return $trend
#@ }
#@ 
#@ define_proc_attributes analyze_trend     -info " Analyze the trend of a float list"     -define_args {
#@       {float_list "The list contains float array for analysis" float_list list required}
#@       {-relative_tolerance "The relative tolerance for the float equal comparing, default is 0.01." relative_tolerance float optional}
#@       {-absolute_tolerance "The absolute tolerance for the float equal comparing, default is 1e-6." absolute_tolerance float optional}
#@ }
#@ 
#@ # -- End source /cad/synopsys/lc/M-2017.06-SP3/auxx/lc/analyze_trend.tcl

#@ source $synopsys_root/auxx/lc/get_scale.tcl
#@ # -- Starting source /cad/synopsys/lc/M-2017.06-SP3/auxx/lc/get_scale.tcl

#@ ##############################################################################
#@ # Proc: get_time_scale   Author: Junhan Yi   Date: 2015/12/09
#@ #   unified time unit is 1ns
#@ #   return the scale value from the unit to the unified unit. 
#@ ##############################################################################
#@ proc get_time_scale { unit } {
#@ 
#@   set val 0
#@ 
#@   scan $unit %f%s digit class
#@   
#@   switch -exact -- $class {
#@     "fs"    { set val 1e-6 }
#@     "ps"    { set val 1e-3 }
#@     "ns"    { set val 1 }
#@     "us"    { set val 1e3 }
#@     "ms"    { set val 1e6 }
#@     "s"     { set val 1e9 }
#@     "ks"    { set val 1e12 }
#@     default { echo "Error! The unit '$unit' is not a 'time' unit" }
#@   }
#@ 
#@   set val [expr $val * $digit]
#@   
#@   return $val
#@ }
#@ # This proc is hidden
#@ define_proc_attributes get_time_scale -hidden
#@ 
#@ ##############################################################################
#@ # Proc: get_voltage_scale   Author: Junhan Yi   Date: 2015/12/09
#@ #   unified voltage unit is 1v
#@ #   return the scale value from the unit to the unified unit. 
#@ ##############################################################################
#@ proc get_voltage_scale { unit } {
#@ 
#@   set val 0
#@ 
#@   scan $unit %f%s digit class
#@   
#@   switch -exact -- $class {
#@     "fv"    { set val 1e-15 }
#@     "pv"    { set val 1e-12 }
#@     "nv"    { set val 1e-9 }
#@     "uv"    { set val 1e-6 }
#@     "mv"    { set val 1e-3 }
#@     "v"     { set val 1 }
#@     "kv"    { set val 1e3 }
#@     default { echo "Error! The unit '$unit' is not a 'voltage' unit" }
#@   }
#@ 
#@   set val [expr $val * $digit]
#@   
#@   return $val
#@ }
#@ # This proc is hidden
#@ define_proc_attributes get_voltage_scale -hidden
#@ 
#@ ##############################################################################
#@ # Proc: get_current_scale   Author: Junhan Yi   Date: 2015/12/09
#@ #   unified current unit is 1a
#@ #   return the scale value from the unit to the unified unit. 
#@ ##############################################################################
#@ proc get_current_scale { unit } {
#@ 
#@   set val 0
#@ 
#@   scan $unit %f%s digit class
#@ 
#@   switch -exact -- $class {
#@     "fa"    { set val 1e-15 }
#@     "pa"    { set val 1e-12 }
#@     "na"    { set val 1e-9 }
#@     "ua"    { set val 1e-6 }
#@     "ma"    { set val 1e-3 }
#@     "a"     { set val 1 }
#@     "ka"    { set val 1e3 }
#@     default { echo "Error! The unit '$unit' is not a 'current' unit" }
#@   }
#@   
#@   set val [expr $val * $digit]
#@   
#@   return $val
#@ }
#@ # This proc is hidden
#@ define_proc_attributes get_current_scale -hidden
#@ 
#@ ##############################################################################
#@ # Proc: get_power_scale   Author: Junhan Yi   Date: 2015/12/09
#@ #   unified power unit is 1w
#@ #   return the scale value from the unit to the unified unit. 
#@ ##############################################################################
#@ proc get_power_scale { unit } {
#@ 
#@   set val 0
#@ 
#@   scan $unit %f%s digit class
#@ 
#@   switch -exact -- $class {
#@     "fw"    { set val 1e-15 }
#@     "pw"    { set val 1e-12 }
#@     "nw"    { set val 1e-9 }
#@     "uw"    { set val 1e-6 }
#@     "mw"    { set val 1e-3 }
#@     "w"     { set val 1 }
#@     "kw"    { set val 1e3 }
#@     default { echo "Error! The unit '$unit' is not a 'power' unit" }
#@   }
#@   
#@   set val [expr $val * $digit]
#@   
#@   return $val
#@ }
#@ # This proc is hidden
#@ define_proc_attributes get_power_scale -hidden
#@ 
#@ ##############################################################################
#@ # Proc: get_resistance_scale   Author: Junhan Yi   Date: 2015/12/09
#@ #   unified resistance unit is 1ohm
#@ #   return the scale value from the unit to the unified unit. 
#@ ##############################################################################
#@ proc get_resistance_scale { unit } {
#@ 
#@   set val 0
#@ 
#@   scan $unit %f%s digit class
#@ 
#@   switch -exact -- $class {
#@     "fohm"    { set val 1e-15 }
#@     "pohm"    { set val 1e-12 }
#@     "nohm"    { set val 1e-9 }
#@     "uohm"    { set val 1e-6 }
#@     "mohm"    { set val 1e-3 }
#@     "ohm"     { set val 1 }
#@     "kohm"    { set val 1e3 }
#@     default  { echo "Error! The unit '$unit' is not a 'resistance' unit" }
#@   }
#@   
#@   set val [expr $val * $digit]
#@   
#@   return $val
#@ }
#@ # This proc is hidden
#@ define_proc_attributes get_resistance_scale -hidden
#@ 
#@ ##############################################################################
#@ # Proc: get_capacitance_scale   Author: Junhan Yi   Date: 2015/12/09
#@ #   unified capacitance unit is 1f
#@ #   return the scale value from the unit to the unified unit. 
#@ ##############################################################################
#@ proc get_capacitance_scale { unit } {
#@ 
#@   set val 0
#@ 
#@   scan $unit %f%s digit class
#@ 
#@   switch -exact -- $class {
#@     "ff"    { set val 1e-15 }
#@     "pf"    { set val 1e-12 }
#@     "nf"    { set val 1e-9 }
#@     "uf"    { set val 1e-6 }
#@     "mf"    { set val 1e-3 }
#@     "f"     { set val 1 }
#@     "kf"    { set val 1e3 }
#@     default { echo "Error! The unit '$unit' is not a 'capacitance' unit" }
#@   }
#@   
#@   set val [expr $val * $digit]
#@   
#@   return $val
#@ }
#@ # This proc is hidden
#@ define_proc_attributes get_capacitance_scale -hidden
#@ 
#@ ##############################################################################
#@ # Proc: get_energy_scale   Author: Junhan Yi   Date: 2015/12/09
#@ #   unified energy unit is 1j
#@ #   return the scale value from the unit to the unified unit. 
#@ ##############################################################################
#@ proc get_energy_scale { unit } {
#@ 
#@   set val 0
#@ 
#@   scan $unit %f%s digit class
#@ 
#@   switch -exact -- $class {
#@     "fj"    { set val 1e-15 }
#@     "pj"    { set val 1e-12 }
#@     "nj"    { set val 1e-9 }
#@     "uj"    { set val 1e-6 }
#@     "mj"    { set val 1e-3 }
#@     "j"     { set val 1 }
#@     "kj"    { set val 1e3 }
#@     default { echo "Error! The unit '$unit' is not a 'energy' unit" }
#@   }
#@   
#@   set val [expr $val * $digit]
#@   
#@   return $val
#@ }
#@ # This proc is hidden
#@ define_proc_attributes get_energy_scale -hidden
#@ 
#@ ##############################################################################
#@ # Proc: get_scale   Author: Junhan Yi   Date: 2015/12/09
#@ #   This command will analyze the unit in the source library, and return 
#@ #   the scale value from the library unit to the target unit. 
#@ #   If any error happens, return 0.
#@ # -type: Unit type (time| voltage| current | power| capacitance | resistance| energy)
#@ # -target_unit: The target unit for sacle 
#@ #     [float][magnitude][unit]
#@ # -library: The source library.
#@ # For example: get_scale time 10.0ps $lib
#@ # Recommand unit type:
#@ #     For time: 1ps| 1ns
#@ #	    For voltage: 1mv| 1v
#@ #	    For current: 1ua| 1ma| 1a
#@ #	    For power: 1pw| 1nw| 1uw| 1mw
#@ #	    For capacitance: 1ff| 1pf
#@ #	    For resistance: 1ohm| 1kohm
#@ #	    For energy: 1fj| 1pj| 1nj| 1uj
#@ ##############################################################################
#@ proc get_scale { args } {
#@ 
#@   set val 0 
#@   
#@   # get the args
#@   parse_proc_arguments -args $args ra
#@   set type $ra(type)
#@   set target_unit $ra(target_unit)
#@   set library $ra(library)
#@   
#@   # time
#@   if { $type=="time" } {
#@     set t_unit_scale [get_time_scale $target_unit]
#@     set unit [get_lib_attribute $library time_unit]
#@     set s_unit_scale [get_time_scale $unit]
#@     if {$t_unit_scale>0 && $s_unit_scale>0} {
#@       set val [expr $s_unit_scale/$t_unit_scale]
#@     }
#@ 
#@   # voltage
#@   } elseif { $type=="voltage" } {
#@     set t_unit_scale [get_voltage_scale $target_unit]
#@     set unit [get_lib_attribute $library voltage_unit]
#@     set s_unit_scale [get_voltage_scale $unit]
#@     if {$t_unit_scale>0 && $s_unit_scale>0} {
#@       set val [expr $s_unit_scale/$t_unit_scale]
#@     }
#@ 
#@   # current
#@   } elseif { $type=="current" } {
#@     set t_unit_scale [get_current_scale $target_unit]
#@     set unit [get_lib_attribute $library current_unit]
#@     set s_unit_scale [get_current_scale $unit]
#@     if {$t_unit_scale>0 && $s_unit_scale>0} {
#@       set val [expr $s_unit_scale/$t_unit_scale]
#@     }
#@ 
#@   # power
#@   } elseif { $type=="power" } {
#@     set t_unit_scale [get_power_scale $target_unit]
#@     set unit [get_lib_attribute $library leakage_power_unit]
#@     set s_unit_scale [get_power_scale $unit]
#@     if {$t_unit_scale>0 && $s_unit_scale>0} {
#@       set val [expr $s_unit_scale/$t_unit_scale]
#@     }
#@ 
#@   # capacitance
#@   } elseif { $type=="capacitance" } {
#@     set t_unit_scale [get_capacitance_scale $target_unit]
#@     # unit is string like "xxxpf" or "xxxff" returned by get_lib_attribute
#@     set unit [get_lib_attribute $library capacitive_load_unit]
#@     set s_unit_scale [get_capacitance_scale $unit]
#@     if {$t_unit_scale>0 && $s_unit_scale>0} {
#@       set val [expr $s_unit_scale/$t_unit_scale]
#@     }
#@     
#@   # resistance
#@   } elseif { $type=="resistance" } {
#@     set t_unit_scale [get_resistance_scale $target_unit]
#@     set unit [get_lib_attribute $library pulling_resistance_unit]
#@     set s_unit_scale [get_resistance_scale $unit]
#@     if {$t_unit_scale>0 && $s_unit_scale>0} {
#@       set val [expr $s_unit_scale/$t_unit_scale]
#@     }
#@ 
#@   # energy
#@   } elseif { $type=="energy" } {
#@     set t_unit_scale [get_energy_scale $target_unit]
#@     # c_unit is string like "xxxpf" or "xxxff" returned by get_lib_attribute
#@     set c_unit [get_lib_attribute $library capacitive_load_unit]
#@     set c_unit [get_capacitance_scale $c_unit]
#@     set v_unit [get_lib_attribute $library voltage_unit]
#@     set v_unit_scale [get_voltage_scale $v_unit]
#@     set s_unit_scale [expr $c_unit * $v_unit_scale * $v_unit_scale]
#@     if {$t_unit_scale>0 && $s_unit_scale>0} {
#@       set val [expr $s_unit_scale/$t_unit_scale]
#@     }
#@   }
#@  
#@   return $val
#@   
#@ }
#@ 
#@ define_proc_attributes get_scale     -info " Get the scaling value from source library to target unit."     -define_args {
#@       {type "Unit type" type one_of_string {required value_help {values {time voltage current power capacitance resistance energy}}}}
#@       {target_unit "The target unit for scaling" target_unit string required }
#@       {library "The source library object" library list required}
#@ }
#@ 
#@ # -- End source /cad/synopsys/lc/M-2017.06-SP3/auxx/lc/get_scale.tcl

#@ source $synopsys_root/auxx/lc/plot_table.tcl
#@ # -- Starting source /cad/synopsys/lc/M-2017.06-SP3/auxx/lc/plot_table.tcl

#@ ##############################################################################
#@ # 'global' parameters   Author: James Zhang   Date: 2016/9/18
#@ ##############################################################################
#@ 
#@ # temp path to accommodate plot data and script 
#@ set lc_plot_table_base_dir  "/tmp/lc_plot_table_"
#@ set lc_plot_table_list_dirs  ""  ;# a list for tmp dirs
#@ 
#@ # to accommodate PIDs & COMMANDs of xterm being executed
#@ set lc_plot_table_pids      ""
#@ set lc_plot_table_cmds      ""
#@ 
#@ ##############################################################################
#@ # Proc: createUniqueDir   Author: James Zhang   Date: 2016/9/18
#@ #   create one unique folder (without tailing backslash) under temp path
#@ # Return: 
#@ #   path of the created folder
#@ ##############################################################################
#@ proc createUniqueDir {} {
#@   set sDir [pid]
#@   append sDir "_" [clock microseconds]
#@   file mkdir $::lc_plot_table_base_dir$sDir
#@   lappend ::lc_plot_table_list_dirs $sDir
#@   return $::lc_plot_table_base_dir$sDir
#@ }
#@ # This proc is hidden
#@ define_proc_attributes createUniqueDir -hidden
#@ 
#@ ##############################################################################
#@ # Proc: clearSpot   Author: James Zhang   Date: 2016/9/18
#@ #   delete the previous intermediate gnuplot data and script
#@ ##############################################################################
#@ proc clearSpot {} {
#@   # close the previous opened terminals
#@   set i 0
#@   foreach sPid $::lc_plot_table_pids {
#@     # check if pid existed
#@     if { [catch {exec kill -0 $sPid}]==0 } {
#@       set sCmd [lindex $::lc_plot_table_cmds $i]
#@       # check if the COMMAND of the pid is exactly the "xterm ..." which was forked by 'me' (plot_table)  
#@       if { [catch {exec ps u | awk {{for(ii=11;ii<=NF;ii++)printf $ii" ";printf "\n"}} | grep -e ^$sCmd}]==0 } {
#@         # kill the process
#@         catch {exec kill $sPid} msg
#@       }
#@     }    
#@     
#@     incr i
#@   }
#@   set ::lc_plot_table_pids  ""
#@   set ::lc_plot_table_cmds  ""
#@   
#@   # delete the previous intermediate gnuplot data and script
#@   foreach sDir $::lc_plot_table_list_dirs {
#@     file delete -force $::lc_plot_table_base_dir$sDir
#@   }
#@   set ::lc_plot_table_list_dirs  ""
#@ }
#@ # This proc is hidden
#@ define_proc_attributes clearSpot -hidden
#@ 
#@ ##############################################################################
#@ # Proc: genPlotData   Author: James Zhang   Date: 2016/10/28
#@ #   generate plot data
#@ # Arguments:
#@ #   lut     lookup_table object
#@ #   sDat    path of plot data file
#@ # Return:
#@ #   1 proc succeeded, 0 otherwise
#@ ##############################################################################
#@ proc genPlotData { lut sDat } {
#@   if [catch {open $sDat w} pDat] {
#@     puts "error, failed to open $sDat for write:$pDat"
#@     return 0
#@   }
#@ 
#@   set nDim [lookup_table dimension $lut]
#@   
#@   set vIdx [lookup_table index $lut]
#@   set vIdx0 [lindex $vIdx 0]
#@   
#@   set vVal [lookup_table slice -all $lut]
#@   set k 0
#@   
#@   if { $nDim==2 } {
#@     set vIdx1 [lindex $vIdx 1]
#@     foreach i $vIdx0 {
#@       foreach j $vIdx1 {
#@         puts $pDat "$i $j [lindex $vVal $k]"
#@         incr k
#@       }
#@       puts $pDat ""
#@     }
#@   } else {
#@     foreach i $vIdx0 {
#@       puts $pDat "$i [lindex $vVal $k]"
#@       incr k
#@     }
#@   }
#@   
#@   close $pDat
#@   return 1
#@ }
#@ # This proc is hidden
#@ define_proc_attributes genPlotData -hidden
#@ 
#@ ##############################################################################
#@ # Proc: genPlotDataForCcs   Author: James Zhang   Date: 2016/10/21
#@ #   generate plot data file for CCS object
#@ # Arguments:
#@ #   lut               lookup_table CCS object
#@ #   sDat              path of plot data file
#@ #   vVarIdx           grid points of the object e.g. {var1 index1 var2 index2}
#@ #   fInitV1           Vss(Vdd) as initial V1 for derived voltage
#@ #   sOvExpr(up-level) customized equation to derive voltage, it will be set to 
#@ #                     empty if invalid expression. This makes 
#@ #                     genPlotDataForCcsPlotAll() comfortable
#@ # Return:
#@ #   1 proc succeeded, 0 otherwise
#@ ##############################################################################
#@ proc genPlotDataForCcs { lut sDat vVarIdx fInitV1 } {
#@   upvar sOvExpr sOvExprRef
#@   
#@   if [catch {open $sDat w} pDat] {
#@     puts "error, failed to open $sDat for write:$pDat"
#@     return 0
#@   }
#@   
#@   set fLoad -1.0
#@   if { [string equal [lindex $vVarIdx 0] "total_output_net_capacitance"]} {
#@     set fLoad [lindex $vVarIdx 1]
#@   } elseif { [string equal [lindex $vVarIdx 2] "total_output_net_capacitance"]} {
#@     set fLoad [lindex $vVarIdx 3]
#@   }
#@   
#@   set fVpre $fInitV1
#@   set fI 0.0
#@   set fIpre 0.0
#@   set fT 0.0
#@   set fTpre 0.0
#@   set fV 0.0
#@   
#@   set fTRef [lookup_table slice $lut -data ref -index $vVarIdx]
#@   if { [string length $fTRef]==0 } {
#@     set fTRef 0.0
#@   }
#@   if { [string equal $fTRef "0.0"] } {
#@     set fLoad -1.0
#@   }
#@   set vT [lookup_table slice $lut -data time -index $vVarIdx]
#@   set vI [lookup_table slice $lut -data values -index $vVarIdx]
#@   set nT [llength $vT]
#@   set nI [llength $vI]
#@   if { $nT!=$nI } {
#@     puts "error, size of time ($nT) != size of values ($nI)"
#@     close $pDat
#@     return 0
#@   }
#@   
#@   for { set i 0 } { $i<$nT } { incr i } {
#@     set fT [expr [lindex $vT $i]-$fTRef]
#@     set fI [lindex $vI $i]
#@     if { $fLoad > 0 } {
#@       if { [string length $sOvExprRef]!=0 } {
#@         set sOvExprTmp $sOvExprRef
#@         regsub -all "V1" $sOvExprTmp $fVpre sOvExprTmp
#@         regsub -all "I2" $sOvExprTmp $fI sOvExprTmp
#@         regsub -all "I1" $sOvExprTmp $fIpre sOvExprTmp
#@         regsub -all "T2" $sOvExprTmp $fT sOvExprTmp
#@         regsub -all "T1" $sOvExprTmp $fTpre sOvExprTmp
#@         regsub -all "C" $sOvExprTmp $fLoad sOvExprTmp
#@         if { [string length $sOvExprTmp]==0 } {
#@           set fExpr ""
#@         } else {
#@           set fExpr [expr $sOvExprTmp]
#@         }
#@         if { [string length $fExpr]==0 } {
#@           echo "warning, failed to get result of the process($sOvExprRef) from predefined variables: V1($fVpre), I2($fI), I1($fIpre), T2($fT), T1($fTpre), C($fLoad).\nTurn to use built-in default process(V1+0.5/C*(I2+I1)*(T2-T1))."
#@           set sOvExprRef "" ;# make genPlotDataForCcsPlotAll() comfortable
#@           set fV [expr $fVpre+0.5*($fI+$fIpre)*($fT-$fTpre)/$fLoad]
#@         } else {
#@           set fV $fExpr
#@         }
#@       } else {
#@         set fV [expr $fVpre+0.5*($fI+$fIpre)*($fT-$fTpre)/$fLoad]
#@       }
#@       set fVpre $fV
#@       set fIpre $fI
#@       set fTpre $fT
#@     } else {
#@       # "total_output_net_capacitance" is not there?
#@       # or no calculated voltage at all
#@       set fV 0.0
#@     }
#@     puts $pDat "$fT $fI $fV"
#@   }
#@   
#@   close $pDat
#@   return 1
#@ }
#@ # This proc is hidden
#@ define_proc_attributes genPlotDataForCcs -hidden
#@ 
#@ ##############################################################################
#@ # Proc: genPlotDataForCcsPlotAll   Author: James Zhang   Date: 2016/10/21
#@ #   generate plot data files for all grid points of the CCS object
#@ # Arguments:
#@ #   lut               lookup_table CCS object
#@ #   sFnPrefix         folder (with tailing backslash) to accommodate data file
#@ #   sOvExpr           customized equation to derive voltage
#@ #   fInitV1           Vss(Vdd) as initial V1 for derived voltage
#@ #   vDat(up-level)    paths of plot data files
#@ # Return:
#@ #   1 proc succeeded, 0 otherwise
#@ ##############################################################################
#@ proc genPlotDataForCcsPlotAll { lut sFnPrefix sOvExpr fInitV1 } {
#@   # set an alias of up-level parameter, which will point to the same memory of
#@   # the parameter in up-level proc. (I think this is most like using reference
#@   # as function parameter in C++)
#@   upvar vDat vDatRef
#@   set vDatRef ""
#@ 
#@   set vVar [lookup_table variables $lut]  ;# e.g. "input_net_transition total_output_net_capacitance"
#@   set vIdx [lookup_table index $lut]      ;# e.g. "{0.00114139996003 0.00220229988918 ...} {......}"
#@   
#@   # 1d and 2d lookup tables supported by now, sanity check already done in main
#@   # procedure
#@   set nDim [llength $vVar]
#@   # if { $nDim < 1 || $nDim > 2 } {
#@   #   return -code error "...\n"
#@   # }
#@   
#@   set sVar0 [lindex $vVar 0]
#@   set nIdx0Size [llength [lindex $vIdx 0]]
#@   
#@   if { $nDim > 1 } {
#@     set sVar1 [lindex $vVar 1]
#@     set nIdx1Size [llength [lindex $vIdx 1]]
#@   }
#@   
#@   for { set i 0 } { $i<$nIdx0Size } { incr i } {
#@     set fIdx0 [lindex [lindex $vIdx 0] $i]
#@     if { $nDim==1 } {
#@       set sDat $sFnPrefix
#@       append sDat "lut" [expr $i+1] ".dat"
#@       set vVarIdx [ list $sVar0 $fIdx0 ]
#@       set ret [genPlotDataForCcs $lut $sDat $vVarIdx $fInitV1]
#@       if { $ret==0 } {
#@         return 0
#@       }
#@       lappend vDatRef $sDat
#@     } elseif { $nDim==2 } {
#@       for { set j 0 } { $j<$nIdx1Size } { incr j } {
#@         set fIdx1 [lindex [lindex $vIdx 1] $j]
#@         set sDat $sFnPrefix
#@         append sDat "lut" [expr $i*$nIdx1Size+$j+1] ".dat"
#@         set vVarIdx [ list $sVar0 $fIdx0 $sVar1 $fIdx1 ]
#@         set ret [genPlotDataForCcs $lut $sDat $vVarIdx $fInitV1]
#@         if { $ret==0 } {
#@           return 0
#@         }
#@         lappend vDatRef $sDat
#@       }
#@     } ;# else 3d ...
#@   }
#@   
#@   return 1
#@ }
#@ # This proc is hidden
#@ define_proc_attributes genPlotDataForCcsPlotAll -hidden
#@ 
#@ ##############################################################################
#@ # Proc: getInfoString   Author: James Zhang   Date: 2016/10/27
#@ #   get information of lookup_table object
#@ # Arguments:
#@ #   lut               lookup_table object
#@ # Return:
#@ #   information string of the object
#@ ##############################################################################
#@ proc getInfoString { lut } {
#@   set sInfo ""
#@   
#@   set sTmpl [lookup_table template_name $lut]
#@   if { [string length $sTmpl]!=0 } {
#@     append sInfo " template(" $sTmpl ")"
#@   }
#@   
#@   set nDim [lookup_table dimension $lut]
#@   set vSize [lookup_table sizes $lut]
#@   if { $nDim>0 } {
#@     append sInfo " size(" [lindex $vSize 0]
#@   }
#@   if { $nDim>1 } {
#@     append sInfo "x" [lindex $vSize 1]
#@   }
#@   if { $nDim>2 } {
#@     append sInfo "x" [lindex $vSize 2]
#@   }
#@   if { $nDim>0 } {
#@     append sInfo ")"
#@   }
#@ 
#@   return $sInfo
#@ }
#@ # This proc is hidden
#@ define_proc_attributes getInfoString -hidden
#@ 
#@ ##############################################################################
#@ # Proc: printFile   Author: James Zhang   Date: 2016/11/25
#@ #   print out file content
#@ # Arguments:
#@ #   sDat               file path
#@ # Return:
#@ #   1 proc succeeded, 0 otherwise
#@ ##############################################################################
#@ proc printFile { sDat } {
#@   set sDelimit "================================================================================"
#@ 
#@   puts ""
#@   if [catch {open $sDat r} pDat] {
#@     puts "error, failed to open $sDat for read:$pDat"
#@     return 0
#@   }
#@   puts [file tail $sDat]
#@   puts $sDelimit
#@   puts [read $pDat]
#@   puts $sDelimit
#@   close $pDat      
#@ 
#@   return 1
#@ }
#@ # This proc is hidden
#@ define_proc_attributes printFile -hidden
#@ 
#@ ##############################################################################
#@ # Proc: plot_table   Author: James Zhang   Date: 2016/9/18
#@ #   plot lookup table(s) in lc_shell, using 'gnuplot'.
#@ # Arguments:
#@ #   see define_proc_attributes section 
#@ # Return:
#@ #   1 proc succeeded, 0 or error code otherwise
#@ # Examples:
#@ #   moved to man page: plot_table.3
#@ ##############################################################################
#@ proc plot_table {args} {
#@   # supported after set lc_enable_plot_table true
#@   if { [info exists ::lc_enable_plot_table]!=1 || [string equal -nocase $::lc_enable_plot_table "true"]!=1 } {
#@ #     return -code error "UIL-100 (error) The command is not enabled. You need to set lc_enable_plot_table beforehand."
#@     return ""
#@   }
#@   # supported in lc_advanced_tcl_mode
#@   if { [info exists ::lc_advanced_tcl_mode]!=1 || [string equal -nocase $::lc_advanced_tcl_mode "true"]!=1 } {
#@     return -code error "UIL-100 (error) The command is not enabled, it's support in advanced tcl mode only."
#@   }
#@   set i 0
#@   
#@   # get the args
#@   parse_proc_arguments -args $args ra
#@   
#@   # -clear, which is an individual arg
#@   if { [string length [array names ra -clear]] != 0 } {
#@     clearSpot
#@     return "1"
#@   }
#@   
#@   # create one more unique dir for data/script
#@   set sFnPrefix [createUniqueDir]
#@   append sFnPrefix "/"
#@   
#@   # luts: list of lookup tables, which is the main arg
#@   set vLut ""
#@   if { [string length [array names ra luts]] != 0 } {
#@     set vLut $ra(luts)
#@   }
#@   set nObjSize [llength $vLut]
#@   if {$nObjSize < 1} {
#@     return -code error "No lookup table is specified.\n"
#@   }
#@  
#@   #
#@   # sanity check and preparation
#@   #
#@   set bIsCCS 0
#@   set bIsCCSPlotAll 0
#@   set nDim 0
#@   set sDat ""
#@   set vDat ""   ;# filenames of data
#@   foreach lut $vLut {
#@     set vSize [lookup_table sizes $lut] ;# e.g. "8" (1d), "8 7" (2d)
#@     if {[llength $vSize] < 1} {
#@       return -code error "Specified object ($lut) is NOT a lookup table.\n"
#@     }
#@     
#@     set nDimTmp [lookup_table dimension $lut]
#@     if { $nDimTmp < 1 || $nDimTmp > 2 } {
#@       # 1d and 2d lookup tables supported by now
#@       return -code error "Not supported for $nDimTmp dimension(s).\n"
#@     }
#@     if {[llength [lookup_table slice $lut -all]] < 1} {
#@       # this is a CCS object
#@       set nDim $nDimTmp
#@       if {$nObjSize > 1} {
#@         return -code error "Multiple lookup tables are not supported for CCS object\n"
#@       }
#@       set bIsCCS 1
#@       # -index, used to specify one slice of CCS object
#@       set vVarIdx ""
#@       if { [string length [array names ra -index]] != 0 } {
#@         set vVarIdx $ra(-index)
#@       }
#@       set nVarIdxSize [llength $vVarIdx]
#@       if { $nVarIdxSize==0 } {
#@         set bIsCCSPlotAll 1
#@       } elseif { $nVarIdxSize==1 } {
#@         # e.g. "0:0"  --> "input_net_transition 0.00726140011102 total_output_net_capacitance 0.000390200002585"
#@         # e.g. "0"    --> "input_net_transition 0.00726140011102"
#@         set vId [split $vVarIdx ":"]
#@         if {[llength $vId] != $nDim} {
#@           return -code error "Specified index ($vVarIdx) is unmatched with the object of $nDim dimension(s).\n"
#@         }
#@         set vVar [lookup_table variables $lut]
#@         set vIdx [lookup_table index $lut]
#@         if { $nDim==1 } {
#@           set vVarIdx [ list [lindex $vVar 0]             [lindex [lindex $vIdx 0] [expr [lindex $vId 0]]] ]
#@         } elseif { $nDim==2 } {
#@           set vVarIdx [ list [lindex $vVar 0]             [lindex [lindex $vIdx 0] [expr [lindex $vId 0]]]             [lindex $vVar 1]             [lindex [lindex $vIdx 1] [expr [lindex $vId 1]]] ]
#@         } ;# else 3d ...
#@       } ;# else more than 1 elements in $vVarIdx, leave check to lookup_table. e.g. "input_net_transition 0.00726140011102"
#@     } else {
#@       # this is NOT a CCS object
#@       if { $i > 0 } {
#@         if { $nDimTmp != $nDim } {
#@           return -code error "Different dimension(s) of multiple lookup tables can't be plotted at once.\n"
#@         } 
#@       } else {
#@         set nDim $nDimTmp
#@       }
#@     }
#@     if { $bIsCCSPlotAll==0 } {
#@       set sDat $sFnPrefix
#@       append sDat "lut" [expr $i+1] ".dat"
#@       lappend vDat $sDat
#@     }
#@     incr i
#@   }
#@  
#@   # -derive_output_voltage, enable voltage curve for CCS object
#@   set bOmitExpr 1
#@   if { [string length [array names ra -derive_output_voltage]] != 0 } {
#@     set bOmitExpr 0
#@   }
#@   if { $bOmitExpr==0 && $bIsCCS==0 } {
#@     echo "warning, -derive_output_voltage option won't work for non-CCS objects, ommitted.\n"
#@     set bOmitExpr 1
#@   }
#@ 
#@   # -derive_output_voltage_equation
#@   set sOvExpr ""  ;# customized expression, empty if N/A or invalid
#@   if { $bOmitExpr==0 && [string length [array names ra -derive_output_voltage_equation]] != 0 } {
#@     set sOvExpr $ra(-derive_output_voltage_equation)
#@   }
#@   
#@   # -legend, to customize legends
#@   set itLegend ""
#@   if { [string length [array names ra -legend]] != 0 } {
#@     set itLegend $ra(-legend) ;# it* is actually list_*
#@   }
#@   set vLegend ""              ;# v* is also list_*
#@   set sLegend ""
#@ 
#@   # -initv1, Vss(Vdd) as initial V1 for derived voltage
#@   set fInitV1 0.0
#@   if { [string length [array names ra -initv1]] != 0 } {
#@     set fInitV1 $ra(-initv1)
#@   }
#@   
#@   #
#@   # generate data, prepare legends for plotting
#@   #
#@   set i 0
#@   foreach lut $vLut {
#@     if { $bIsCCSPlotAll==1 } {
#@       set ret [genPlotDataForCcsPlotAll $lut $sFnPrefix $sOvExpr $fInitV1]
#@       if { $ret==0 } {
#@         return 0
#@       }
#@     } elseif { $bIsCCS==1 } {
#@       set ret [genPlotDataForCcs $lut [lindex $vDat 0] $vVarIdx $fInitV1]
#@       if { $ret==0 } {
#@         return 0
#@       }
#@     } else {
#@       set ret [genPlotData $lut [lindex $vDat $i]]
#@       if { $ret==0 } {
#@         return 0
#@       }
#@     
#@       # initialize legend for non-CCS object(s)
#@       if { [string length [lindex $itLegend $i]]!=0 } {
#@         set sLegend [lindex $itLegend $i]
#@         # speical characters needs to be converted
#@         regsub -all {\\} $sLegend {\\\\} sLegend
#@         regsub -all "\"" $sLegend "\\\"" sLegend
#@       } else {
#@         set sLegend "lut"
#@         append sLegend [expr $i+1]
#@       }
#@       append sLegend [getInfoString $lut]
#@       lappend vLegend $sLegend
#@     }
#@     incr i
#@   }
#@   
#@   # initialize legends for CCS object
#@   if { $bIsCCS==1 } {
#@     for { set i 0 } { $i<2 } { incr i } {
#@       if { [string length [lindex $itLegend $i]]!=0 } {
#@         set sLegend [lindex $itLegend $i]
#@         # speical characters needs to be converted
#@         regsub -all {\\} $sLegend {\\\\} sLegend
#@         regsub -all "\"" $sLegend "\\\"" sLegend
#@       } else {
#@         if { $i==0 } {
#@           set sLegend "y= current"
#@         } elseif { [string length $sOvExpr]==0 } {
#@           set sLegend "y2= V1+0.5/C*(I2+I1)*(T2-T1)"
#@         } else {
#@           set sLegend "y2= $sOvExpr"
#@         }
#@       }
#@       lappend vLegend $sLegend
#@     }
#@   }
#@   
#@   # -aux, to add auxiliary curves or surfaces, currently +-*/ supported
#@   set sAuxAppend ""
#@   if { [string length [array names ra -aux]] != 0 } {
#@     set itEq $ra(-aux)
#@     set i 0
#@     foreach sEq $itEq {
#@       set sEqTmp $sEq
#@       regsub -all "X" $sEqTmp -1.67345 sEqTmp
#@       if { $nDim==2 } {
#@         regsub -all "Y" $sEqTmp 864.195 sEqTmp
#@       }
#@       if { [string length $sEqTmp]==0 } {
#@         set fExpr ""
#@       } else {
#@         set fExpr [expr $sEqTmp]
#@       }
#@       if { [string length $fExpr]!=0 } {
#@         append sAuxAppend "," $sEq
#@         if { $bIsCCS==1 } {
#@           append sAuxAppend " title \"y= $sEq\" axes x1y1"  ;# plot auxiliaries to 1st Y-Axis for CCS
#@         }
#@       } else {
#@         echo "warning, no.[expr $i+1] -aux equation($sEq) is invalid and omitted. Currently, arithmetic operations(+-*/) are supported. The variable names X and Y are used as the default independent variables. Additionally, Y is only supported for 2 dimension tables.\n"
#@       }
#@       incr i
#@     }
#@   }
#@   
#@   # -aux2, to add auxiliary curves to 2nd Y-Axis for CCS only, currently +-*/ supported
#@   if { [string length [array names ra -aux2]] != 0 } {
#@     set itEq $ra(-aux2)
#@     set i 0
#@     foreach sEq $itEq {
#@       set sEqTmp $sEq
#@       regsub -all "X" $sEqTmp -1.67345 sEqTmp
#@       if { $nDim==2 } {
#@         regsub -all "Y" $sEqTmp 864.195 sEqTmp
#@       }
#@       if { [string length $sEqTmp]==0 } {
#@         set fExpr ""
#@       } else {
#@         set fExpr [expr $sEqTmp]
#@       }
#@       if { [string length $fExpr]!=0 } {
#@         if { $bIsCCS==1 } {
#@           append sAuxAppend "," $sEq
#@           append sAuxAppend " title \"y2= $sEq\" axes x1y2"  ;# plot auxiliaries to 2nd Y-Axis for CCS only
#@         }
#@       } else {
#@         echo "warning, no.[expr $i+1] -aux2 equation($sEq) is invalid and omitted. Currently, arithmetic operations(+-*/) are supported. The variable names X and Y are used as the default independent variables. Additionally, Y is only supported for 2 dimension tables.\n"
#@       }
#@       incr i
#@     }
#@   }
#@   
#@   # -title, -xlabel, -ylabel, -y2label, several simple 'string' arguments
#@   set sTitle ""
#@   if { [string length [array names ra -title]] != 0 } {
#@     set sTitle $ra(-title)
#@   }
#@   set sXlabel ""
#@   if { [string length [array names ra -xlabel]] != 0 } {
#@     set sXlabel $ra(-xlabel)
#@   }
#@   set sYlabel ""
#@   if { [string length [array names ra -ylabel]] != 0 } {
#@     set sYlabel $ra(-ylabel)
#@   }
#@   set sY2label ""
#@   if { [string length [array names ra -y2label]] != 0 } {
#@     set sY2label $ra(-y2label)
#@   }
#@   
#@   #
#@   # generate main script 'lut.dem'
#@   #
#@   set sDem $sFnPrefix
#@   append sDem "lut.dem"
#@   if [catch {open $sDem w} pDem] {
#@     puts "error, failed to open $sDem for write:$pDem"
#@     return 0
#@   }
#@   puts $pDem "reset"  ;# reset graph-related options to default
#@   if { [string length $sAuxAppend]!=0 } {
#@     if { $bIsCCS==0 && $nDim==2 } {
#@       puts $pDem "set dummy X,Y"
#@     } else {
#@       puts $pDem "set dummy X"
#@     }
#@   }
#@   if { $bIsCCSPlotAll==1 } {
#@     if { [string length $sTitle]!=0 } {
#@       append sTitle "\\n"
#@     }
#@     append sTitle [lindex $vLegend 0]
#@     if { $bOmitExpr==0 } {
#@       append sTitle " vs. " [lindex $vLegend 1]
#@     }
#@     append sTitle [getInfoString $lut]
#@     puts -nonewline $pDem "set multiplot title \"$sTitle\" layout [lindex $vSize 0],"
#@     if { $nDim==1 } {
#@       puts $pDem "1"
#@     } elseif { $nDim==2 } {
#@       puts $pDem "[lindex $vSize 1]"
#@     } ;# else 3d ... (e.g. 5*8*7, maybe 5 windows popped-up?)
#@     puts $pDem "unset border\nunset tics\nunset key"
#@     if { $bOmitExpr==1 } {
#@       foreach sDat $vDat {
#@         puts $pDem "plot \'$sDat\' u 1:2 with lines $sAuxAppend"
#@       }
#@     } else {
#@       foreach sDat $vDat {
#@         puts $pDem "plot \'$sDat\' u 1:2 with lines , \'$sDat\' u 1:3 with lines axes x1y2$sAuxAppend"
#@       }
#@     }
#@     puts $pDem "unset multiplot"
#@   } elseif { $bIsCCS==1 } {
#@     puts $pDem "set ytics nomirror"
#@     puts $pDem "set y2tics"
#@     if { [string length $sTitle]!=0 } {
#@       append sTitle "\\n"
#@     }
#@     foreach vectorVarIndex_i $vVarIdx {
#@       append sTitle $vectorVarIndex_i " "
#@     }
#@     puts $pDem "set title \"$sTitle\""
#@     if { [string length $sXlabel]==0 } {
#@       set sXlabel "time_adjust(T=time-reference_time)"
#@     }
#@     puts $pDem "set xlabel \'$sXlabel\'"
#@     if { [string length $sYlabel]==0 } {
#@       set sYlabel "current(I=vVal)"
#@     }
#@     puts $pDem "set ylabel \'$sYlabel\'"
#@     if { $bOmitExpr==1 } {
#@       puts $pDem "plot \'[lindex $vDat 0]\' using 1:2 with linespoints title \"[lindex $vLegend 0]\"$sAuxAppend"
#@     } else {
#@       if { [string length $sY2label]==0 } {
#@         set sY2label "Vout"
#@       }
#@       puts $pDem "set y2label \'$sY2label\'"
#@       puts $pDem "plot \'[lindex $vDat 0]\' using 1:2 with linespoints title \"[lindex $vLegend 0]\", \'[lindex $vDat 0]\' using 1:3 with linespoints title \"[lindex $vLegend 1]\" axes x1y2$sAuxAppend"
#@     }
#@   } else {
#@     if { [string length $sTitle]!=0 } {
#@       puts $pDem "set title \"$sTitle\""
#@     }
#@     if { $nDim==2 } {
#@       # James Zhang 18:29 2016/10/28
#@       # !!!LOOK OUT!!! in next line the letter before 'nonewline' is a 'â€“' which
#@       # is NOT A CORRECT dash symbol '-':
#@       # puts â€“nonewline $pDem "set hidden3d\n"
#@       puts $pDem "set hidden3d"
#@       if { [string length [array names ra -nogrid]] == 0 } {
#@         puts $pDem "set dgrid3d 50,50,4"
#@       }
#@       puts $pDem "set xyplane at 0.0"
#@       if { [string length $sYlabel]==0 } {
#@         set vVar [lookup_table variables $lut]
#@         set sYlabel [lindex $vVar 1]
#@       }
#@       puts $pDem "set ylabel \'$sYlabel\'"
#@     }
#@     if { [string length $sXlabel]==0 } {
#@       set vVar [lookup_table variables $lut]
#@       set sXlabel [lindex $vVar 0]
#@     }
#@     puts $pDem "set xlabel \'$sXlabel\'"
#@     if { $nDim==2 } {
#@       puts -nonewline $pDem "splot "
#@     } else {
#@       puts -nonewline $pDem "plot "
#@     }
#@     for { set i 0 } { $i<$nObjSize } { incr i } {
#@       if { $i>0 } {
#@         puts -nonewline $pDem ", "
#@       }
#@       puts -nonewline $pDem "\'[lindex $vDat $i]\' with linespoints title \"[lindex $vLegend $i]\""
#@     }
#@     puts $pDem "$sAuxAppend"
#@   }
#@   close $pDem
#@ 
#@   #
#@   # generate a wrapper script 'lut.demw', which sets env. and loads 'lut.dem'
#@   #
#@   set sDemw $sFnPrefix
#@   append sDemw "lut.demw"
#@   if [catch {open $sDemw w} pDemw] {
#@     puts "error, failed to open $sDemw for write:$pDemw"
#@     return 0
#@   }
#@   # save to image file (you need to plot-to-file before plot-to-X11, only 
#@   # the last one being plotted is interactivable!)
#@   set sImgFile ""
#@   if { [string length [array names ra -save]] != 0 } {
#@     set sImgFile $ra(-save)
#@   }
#@   set sCurDir [pwd]
#@   if { [string length $sImgFile]!=0 } {
#@     puts $pDemw "set term png large"
#@     if { [string equal [file pathtype $sImgFile] "absolute"] } {
#@       puts $pDemw "set output \'$sImgFile\'"
#@     } else {
#@       puts $pDemw "set output \'$sCurDir/$sImgFile\'"
#@     }
#@     puts $pDemw "load \'$sDem\'"
#@   }
#@   puts $pDemw "set term X11"    ;# to plot to X11
#@   puts $pDemw "load \'$sDem\'"
#@ 
#@   close $pDemw
#@   
#@   #
#@   # execute 'gnuplot' or dump data/script
#@   #
#@   if { [string length [array names ra -dump]] == 0 } {
#@     cd $sFnPrefix
#@     lappend ::lc_plot_table_pids [exec xterm -e "gnuplot $sDemw -" &]
#@     lappend ::lc_plot_table_cmds "xterm -e gnuplot $sDemw - "
#@     cd $sCurDir
#@   } else {
#@     set bDumpDat 1
#@     set bDumpDem 1
#@     set sDumpOption $ra(-dump)
#@     if { [string equal $sDumpOption "data"] } {
#@       set bDumpDem 0
#@     }
#@     if { [string equal $sDumpOption "script"] } {
#@       set bDumpDat 0
#@     }
#@     
#@     if { $bDumpDat==1 } {
#@       foreach sDat $vDat {
#@         printFile $sDat
#@       }
#@     }
#@     if { $bDumpDem==1 } {
#@       printFile $sDem
#@       printFile $sDemw
#@     }
#@   }
#@   
#@   return 1
#@ }
#@ # This proc is hidden
#@ define_proc_attributes plot_table -hidden
#@ 
#@ # define_proc_attributes plot_table #     -info "plot lookup table(s) by gnuplot." #     -define_args {
#@ #       {luts "lookup table object variables" "object_list" list optional}
#@ #       {-aux "add auxiliary curves or surfaces by equations" "equation_list" list optional}
#@ #       {-aux2 "add auxiliary curves aligning to 2nd Y-Axis for CCS only" "equation_list" list optional}
#@ #       {-derive_output_voltage "add output voltage curve which is derived upon default equation: V1+0.5*(I2+I1)*(T2-T1)/C" "" boolean optional}
#@ #       {-derive_output_voltage_equation "customize the equation to derive output voltage curve" "equation" string optional}
#@ #       {-initv1 "provide Vss(Vdd) as initial V1 for derived voltage" "Vss(Vdd)" string optional}
#@ #       {-index "define grid points or lines" "{variable1 index1 variables2 index2}|index1_id:index2_id" string optional}
#@ #       {-title "title for the plot chart" "title" string optional}
#@ #       {-xlabel "label of x-axis for the plot chart" "xlabel" string optional}
#@ #       {-ylabel "label of y-axis for the plot chart" "ylabel" string optional}
#@ #       {-y2label "label of y2-axis for the plot chart" "y2label" string optional}
#@ #       {-legend "legends for lookup table" "legend_list" list optional}
#@ #       {-save "save to image file in png format" "png_file_path" string optional}
#@ #       {-clear "close all opened terminals and remove all intermediate data" "" boolean optional}
#@ #       {-nogrid "disable grid data mapping (to 50x50) for 3D data, show original data instead" "" boolean optional}
#@ #       {-dump "print out data and/or scripts generated, instead of plot them" "data|script|all" string optional}
#@ # }
#@ # -- End source /cad/synopsys/lc/M-2017.06-SP3/auxx/lc/plot_table.tcl

#@ #for read_lib -html	
#@ source ${synopsys_root}/auxx/lc/read_lib_html_msg_list.tcl
#@ # -- Starting source /cad/synopsys/lc/M-2017.06-SP3/auxx/lc/read_lib_html_msg_list.tcl

#@ ##############################################################################
#@ # message ID and descriptions for read_lib -html
#@ # Rev01. changed LBDB-715 to LBDB-262, STAR 9001225503, jizhan, Aug 17
#@ ##############################################################################
#@ set read_lib_ccs_noise_msg {
#@     LBDB-262
#@     LBDB-660
#@     LBDB-706
#@     LBDB-708
#@     LBDB-709
#@     LBDB-710
#@     LBDB-711
#@     LBDB-712
#@     LBDB-713
#@     LBDB-714
#@     LBDB-716
#@     LBDB-717
#@     LBDB-718
#@     LBDB-733
#@     LBDB-734
#@     LBDB-784
#@     LBDB-824
#@     LBDB-825
#@     LBDB-858
#@     LBDB-898
#@     LBDB-899
#@     LBDB-908
#@     LBDB-920
#@     LBDB-935
#@     LBDB-936
#@     LBDB-937
#@     LBDB-938
#@     LBDB-939
#@ }
#@ # -- End source /cad/synopsys/lc/M-2017.06-SP3/auxx/lc/read_lib_html_msg_list.tcl

#@ alias list_commands help
#@ 
#@ # Temporary fix for the LMC_HOME variable- set it to an empty string 
#@ 
#@ if { [catch {getenv LMC_HOME } __err ] != 0 } {
#@   setenv LMC_HOME ""
#@ }
#@ 
#@ #
#@ #
#@ #       Site-Specific Variables
#@ #
#@ #       These are the variables that are most commonly changed at a
#@ #       specific site, either upon installation of the Synopsys software,
#@ #       or by specific engineers in their local .synopsys_lc.setup files.
#@ #
#@ #
#@ 
#@ # from the System Variable Group 
#@ set search_path [list . ${synopsys_root}/libraries/syn]
#@ 
#@ # do we need command_log_file ?
#@ set command_log_file $sh_command_log_file
#@ 
#@ set view_command_log_file  "./view_command.log"
#@ 
#@ # from the View Variable group
#@ if { $sh_arch == "hp700" } {
#@    set text_print_command  "lp -d" 
#@ } else {
#@    set text_print_command  "lpr -Plw" 
#@ }
#@ 
#@ 
#@ #
#@ #       System Variable Group:
#@ #
#@ #       These variables are system-wide variables.
#@ #
#@ 
#@ set verbose_messages  "true"
#@ set echo_include_commands  "true"
#@ set suppress_errors  {}
#@ 
#@ # variables pertaining to VHDL library generation 
#@ set vhdllib_timing_mesg   "true"
#@ set vhdllib_timing_xgen   "false"
#@ set vhdllib_timing_checks   "true"
#@ set vhdllib_negative_constraint   "false"
#@ set vhdllib_glitch_handle   "true"
#@ set vhdllib_pulse_handle   "use_vhdllib_glitch_handle"
#@ # /*set vhdllib_architecture   {FTBM, UDSM, FTSM, FTGS, VITAL} */
#@ set vhdllib_architecture   {VITAL}
#@ set vhdllib_tb_compare   0
#@ set vhdllib_tb_x_eq_dontcare   FALSE
#@ set vhdllib_logic_system   "ieee-1164"
#@ set vhdllib_logical_name   ""
#@ 
#@ # variables pertaining to technology library processing 
#@ set read_db_lib_warnings   FALSE
#@ set read_translate_msff    TRUE
#@ set libgen_max_differences   -1
#@ 
#@ set view_on_line_doc_cmd ${synopsys_root}/sold
#@ 
#@ # Aliases for backwards compatibility or other reasons 
#@ #alias groupvar          group_variable
#@ alias free		remove_lib
#@ 
#@ # set filename for logging input file 
#@ set filename_log_file   "lc_filenames.log"  
#@ # whether to delete the filename log after the normal exits 
#@ set exit_delete_filename_log_file   "true"
#@ 
#@ #if { lc_shell_status == 0 } {
#@ #  sh echo {Fatal: System .synopsys_lc.setup file not read properly. Please re-invoke.}
#@ #  sh echo {Note that the init file .synopsy_lc.setup of lc_shell}
#@ #  sh echo {is a subset of the dc_shell init file .synopsys_dc.setup.}
#@ #  sh echo {If a non lc_shell command is encountered in the init file,}
#@ #  sh echo {an error message will be issued and the processing might terminate.}
#@ #  sh echo {Please refer to the Library Compiler reference manual for supported commands.}
#@ #  quit
#@ #}
#@ proc get_legacy_lc_search_path { } {
#@   set exec_path "invalid"
#@   if {[info exists ::env(SYNOPSYS_SYN_ROOT)] &&  [file exists $::env(SYNOPSYS_SYN_ROOT)/$::sh_arch/syn/bin/common_shell_exec] } {
#@     set exec_path $::env(SYNOPSYS_SYN_ROOT)/$::sh_arch/syn/bin/common_shell_exec
#@   }
#@   return $exec_path
#@ }
#@ 
#@ proc get_legacy_lc_synopsys_root { } {
#@   return [file dirname [file dirname [file dirname [file dirname $::legacy_lc_search_path] ] ] ] 
#@ }
#@ 
#@ 
#@ proc valias {v_orig v_alias} {
#@    uplevel 1 "upvar 0 $v_orig $v_alias"
#@ }
#@ 
#@ set legacy_lc_result_path "/tmp"
#@ set legacy_lc_replay_tcl_file "common_shell_command.tcl"
#@ set legacy_lc_search_path [get_legacy_lc_search_path]
#@ valias lc_enable_legacy_library_compiler lc_enable_common_shell_lc
#@ 
#@ proc legacy_lc_lib2saif { args } {
#@  return [common_shell_write_lib $args]
#@ }
#@ 
#@ 
#@ proc run_legacy_lc_with_echo {tcl_file} {
#@   set chan [open "|$::legacy_lc_search_path -shell lc_shell -r [get_legacy_lc_synopsys_root] -f $tcl_file" r]
#@ # things to do: In debug mode, we want copy the whole output (beginning to end) 
#@ # to a file
#@   if {$::lc_keep_legacy_lc_temp_files} {
#@       set log [open $::legacy_lc_result_path/$::legacy_lc_log_path/libra.log w]
#@   }
#@   set echo 0
#@   set ret 0
#@   set firstLine true
#@   while {[gets $chan line] >= 0} {
#@       if {$::lc_keep_legacy_lc_temp_files} { puts $log $line }
#@       if {[string equal -length 7 $line "##@@@##"]} {
#@ 	  set echo [expr ! $echo]
#@ 	  continue;
#@       }
#@       if {$echo} { 
#@         if { $firstLine } {
#@           set firstLine false
#@           continue;
#@         } else { 
#@           if {$line == "1"} {
#@             set ret  1
#@           } elseif {$line == "0"} {
#@             set ret 0
#@           } else {
#@             puts $line 
#@           }
#@         }
#@       }
#@   }
#@   close $chan
#@   if {$::lc_keep_legacy_lc_temp_files} {
#@       close $log
#@   }
#@   return $ret;
#@ }
#@ 
#@ proc common_shell_read_lib {args } {
#@   if { [print_no_common_shell_found $::legacy_lc_search_path] } {
#@     return 0
#@   }
#@   set_folder_var
#@   set tcl_file "$::legacy_lc_result_path/$::legacy_lc_log_path/$::legacy_lc_replay_tcl_file"
#@   set chan [open $tcl_file a]
#@   export_tcl_var $chan 
#@   gen_common_shell_read_lib_procedure $chan $args
#@   close $chan
#@   echo "Invoking common shell Library Compiler..."
#@   run_legacy_lc_with_echo $tcl_file
#@   libra_shell_read_dbs
#@   common_shell_clean_up
#@ }
#@ 
#@ proc common_shell_add_pg_pin {args } {
#@   if { [print_no_common_shell_found $::legacy_lc_search_path] } {
#@     return 0
#@   }
#@   # to use error message in synthesis root as the command is called under the hood
#@   set synopsys ""
#@   set synopsys_syn_root ""
#@   if {[info exists ::env(SYNOPSYS)]} {
#@     set synopsys $::env(SYNOPSYS)
#@   }
#@   if {[info exists ::env(SYNOPSYS_SYN_ROOT)]} {
#@     set synopsys_syn_root $::env(SYNOPSYS_SYN_ROOT)
#@   }
#@   if {[string compare "$synopsys"  "$synopsys_syn_root"] && [string compare "$synopsys_syn_root" ""]} {
#@     setenv SYNOPSYS  "$synopsys_syn_root"
#@   }
#@   set_folder_var
#@   set tcl_file "$::legacy_lc_result_path/$::legacy_lc_log_path/$::legacy_lc_replay_tcl_file"
#@   set chan [open $tcl_file a]
#@   export_tcl_var $chan 
#@   gen_common_shell_add_pg_pin_procedure $chan $args
#@   close $chan
#@   run_legacy_lc_with_echo $tcl_file
#@   common_shell_clean_up
#@   # restore SYNOPSYS enviroment after call synthesis
#@   if {[string compare "$synopsys" ""]} {
#@     setenv SYNOPSYS  "$synopsys"
#@   } else {
#@     unsetenv SYNOPSYS
#@   }
#@ }
#@ 
#@ proc common_shell_write_lib {args } {
#@   if { [print_no_common_shell_found $::legacy_lc_search_path] } {
#@     return 0
#@   }
#@   set_folder_var
#@   set tcl_file $::legacy_lc_result_path/$::legacy_lc_log_path/$::legacy_lc_replay_tcl_file
#@   set chan [open $tcl_file a]
#@   export_tcl_var $chan 
#@   libra_shell_write_db
#@   gen_common_shell_write_lib_procedure $chan $args
#@   close $chan
#@   set ret [run_legacy_lc_with_echo $tcl_file]
#@   common_shell_clean_up
#@   return $ret
#@ }
#@ 
#@ proc common_shell_update_lib {args } {
#@   if { [print_no_common_shell_found $::legacy_lc_search_path] } {
#@     return 0
#@   }
#@   set_folder_var
#@   set tcl_file "$::legacy_lc_result_path/$::legacy_lc_log_path/$::legacy_lc_replay_tcl_file"
#@   set chan [open $tcl_file a]
#@   export_tcl_var $chan 
#@   libra_shell_write_db   
#@   gen_common_shell_write_lib_procedure $chan $args
#@   close $chan
#@   run_legacy_lc_with_echo $tcl_file  
#@   libra_shell_read_dbs
#@   common_shell_clean_up
#@ }
#@ 
#@ # create the unique folder under tmp
#@ proc set_folder_var { } {
#@   set fileName [pid]
#@   set ::legacy_lc_log_path [append fileName "_" [clock microseconds]] 
#@   file delete -force $::legacy_lc_result_path/$::legacy_lc_log_path
#@   file mkdir $::legacy_lc_result_path/$::legacy_lc_log_path  
#@ }
#@ 
#@ # export all the vars
#@ proc export_tcl_var { fileName } {
#@   foreach var [info vars ::* ] {
#@     if [array exists $var] {
#@       continue;
#@     }
#@     puts $fileName "set $var \[list [set $var]\]"
#@   }
#@   
#@   global lc_parameter_export_list
#@   foreach var $lc_parameter_export_list {
#@     global $var
#@     puts $fileName "set $var \[list [set $var]\]"
#@   }
#@  
#@   puts $fileName "set search_path \[lappend search_path \$synopsys_root/libraries/syn \$synopsys_root/libraries/syn \$synopsys_root/minpower/syn \$synopsys_root/dw/syn_ver \$synopsys_root/dw/sim_ver\]"
#@ #  puts $fileName "set lc_enable_legacy_library_compiler TRUE"
#@ }
#@ 
#@ # excuted by libra shell to read the dbs generated by common_shell
#@ proc libra_shell_read_dbs { } {
#@   set dbNames ""
#@   foreach var [glob -nocomplain -directory $::legacy_lc_result_path/$::legacy_lc_log_path *.db] { 
#@     append dbNames " " $var
#@     read_db $var 
#@   }
#@   set ::lc_intermediate_db_files $dbNames
#@ }
#@ 
#@ # display the log file genrated by common_shell in Libra and then remove the unique folder
#@ proc common_shell_clean_up { } {
#@   if { ! $::lc_keep_legacy_lc_temp_files } { 
#@     file delete -force $::legacy_lc_result_path/$::legacy_lc_log_path 
#@   }
#@ }
#@ 
#@ # excuted by libra shell to write out the in-memory dbs
#@ proc libra_shell_write_db { } {
#@   foreach db $::lc_intermediate_db_files {
#@     write_lib $db -o $::legacy_lc_result_path/$::legacy_lc_log_path/$db.db
#@   }
#@ }
#@ 
#@ proc gen_common_shell_read_lib_procedure { fileName args} {
#@   puts $fileName "##@@@## gen_common_shell_read_lib"
#@   puts $fileName "eval [lindex [lindex $args 0] 0]"
#@   puts $fileName "##@@@##"
#@   puts $fileName "set lc_write_view_db_file false"
#@   puts $fileName "set librs \[get_libs\]"
#@   puts $fileName "for {set i 0} {\$i < \[ sizeof \$librs \]} {incr i 1} {"
#@   puts $fileName "  set lib \[index_collection \$librs \$i]"
#@   puts $fileName "  redirect -var a \"query_object \$lib\" "
#@   puts $fileName "  if \[regexp {{(\")?(gtech)(\")?}} \$a\] { "
#@   puts $fileName "  } elseif \[regexp {{(\")?(standard.sldb)(\")?}} \$a] { "
#@   puts $fileName "  } else {"
#@   puts $fileName "    regexp {{(\")?(\[^\"\]*)(\")?}} \$a b c d e "
#@   puts $fileName "    write_lib \$d -o \$legacy_lc_result_path/\$legacy_lc_log_path/\$d.db"
#@   puts $fileName "  }"
#@   puts $fileName "}"
#@   puts $fileName "exit"
#@ }
#@ 
#@ proc gen_common_shell_write_lib_procedure { fileName args } {
#@   puts $fileName "foreach var \[glob -nocomplain -directory \$legacy_lc_result_path/\$legacy_lc_log_path *.db\] { read_db \$var }"
#@   puts $fileName "set lc_write_view_db_file false"
#@   puts $fileName "##@@@## gen_common_shell_write_lib"
#@   puts $fileName "eval [lindex [lindex $args 0] 0]"
#@   puts $fileName "##@@@##"
#@   puts $fileName "exit"
#@ }
#@ 
#@ proc gen_common_shell_add_pg_pin_procedure { fileName args } {
#@   puts $fileName "##@@@## gen_common_shell_add_pg_pin"
#@   puts $fileName "eval [lindex $args 0]"
#@   puts $fileName "##@@@##"
#@   puts $fileName "exit"
#@ }
#@ 
#@ proc gen_is_none_tech_file {} {
#@   sh touch $::nglc_result_path/$::nglc_log_path/is_non_tech_file
#@ }
#@ 
#@ proc gen_is_symbol_file {} {
#@   sh touch $::nglc_result_path/$::nglc_log_path/is_symbol_file
#@ }
#@ 
#@ proc print_no_common_shell_found {arg} {
#@   if {![file exists $arg] } {
#@     echo "Error: No common shell Library Compiler found. (LCSH-2)"
#@     return 1
#@   }
#@   return 0
#@ }
#@ 
#@ proc set_host_options args {
#@     global lc_cpu_allocation
#@     if {[string compare [lindex $args 0] "-max_cores"]} {
#@ 	puts "Must specify one of these options: -max_cores. (CMD-004)"
#@ 	return
#@     } elseif {[llength $args] != 2} {
#@ 	puts "value not specified for option '-max_cores' (CMD-008)"
#@ 	return
#@     }
#@     set val [lindex $args 1]
#@     if {[string is integer $val] && ($val > 0) && ($val <= 16) } {
#@ 	set lc_cpu_allocation [expr $val - 1]
#@     } else {
#@ 	puts "value $val for option '-max_cores' not in range (1-16). (CMD-019)"
#@     }
#@     return
#@ }
#@ 
#@ proc remove_host_options {} {
#@     global lc_cpu_allocation
#@     set lc_cpu_allocation 0
#@ }
#@ 
#@ proc report_host_options {} {
#@      global lc_cpu_allocation
#@      global sh_product_version
#@      puts "****************************************
#@ Report : host_options
#@ Version: $sh_product_version
#@ Data   : [date]
#@ ****************************************
#@ 
#@ Max_cores: [expr $lc_cpu_allocation + 1]
#@ "
#@ }
#@ 
#@ define_proc_attributes set_host_options   -info "Controls the maximum number of CPU cores that can be used for read_lib command."   -define_args {
#@     {-max_cores "number_of_cores" max_cores int required}
#@ }
#@ 
#@ define_proc_attributes remove_host_options -info "Removes -max_cores specification set by the set_host_options command."
#@ 
#@ define_proc_attributes report_host_options -info "Prints a report of multi-CPU processing options as defined by the set_host_options command."
#@ 
#@ # to call init_criteria() and pass lc/lc/check_library/logic_sig_digits.tcl
#@ set_check_library_options
#@ # -- End source /cad/synopsys/lc/M-2017.06-SP3/admin/setup//.synopsys_lc.setup

source -echo -verbose /tmp/_pt1rVjCVox
#@ # -- Starting source /tmp/_pt1rVjCVox

#@ echo "ptxr"
#@ set search_path  {  }
#@ set synthetic_library {}
#@ set symbol_library {}
#@ set target_library {}
#@ set generic_symbol_library ""
#@ set hdlin_internal_name_prefix "NN"
#@ set hdlin_auto_netlist_reader "false"
#@ echo "ptxr"
#@ read_lib /home/ajcars/aha/garnet/mflowgen/common/custom-genlibdb-constraints/comb_path_check/synopsys-pt-get-lib-timing-arcs/inputs/design.lib
#@ set all_libdes [get_libs *]
#@ if { [sizeof_collection $all_libdes] == 0 } {
#@   exit
#@ }
#@ set loaded {}
#@ foreach_in_collection libdes $all_libdes {
#@   set a_ld [get_object_name $libdes]
#@   lappend loaded $a_ld
#@ }
#@ write_lib -format db -output /tmp/_pt1rW0gLmH/1.db $a_ld
#@ remove_design -all > /dev/null
#@ exit
